%% FIXME:
%% 1. Space hacking for definitions and list items
%% 2. Tables and array looks
%% 3. Shaded box with \shaded

\newif\ifcomments\commentstrue

\RequirePackage[svgnames,dvipsnames,prologue]{xcolor}

\documentclass[format=acmsmall,manuscript,review,screen,nonacm,margin=1in,11pt]{acmart}

\usepackage{typeclasses}

\title{Dialects of Type Computations in Haskell}
% \subtitle{Typeclasses, functional and Type Families}
\author{Apoorv Ingle}
%\orcid{0000-0002-7399-9762}
\affiliation{%
  \institution{University of Iowa}
  \department{Department of Computer Science}
  \streetaddress{McLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
% \keywords{typeclass, type family}

\begin{document}
\begin{abstract}
  Static types have two advantages: (1) they serve as a guiding tool
  to help programmers write correct code, and (2) the typechecker
  can help identify code that does not behave correctly.
  An expressive type system can guarantee stronger claims about programs.
  Type level computations make the type system more expressive.
  In Haskell, there are two styles of type level computation---functional dependencies
  and type families. In this report we describe these two language features with examples,
  formalize and compare them.
\end{abstract}
\maketitle
%\pagestyle{plain}
\vspace{-1.25em}
\section{Introduction}
Parametric polymorphism is a powerful technique that allows programs to work on
a wide variety of types. The identity function, !id!, that takes an input and returns it
without modification has the type !$\forall$$\alpha$. $\alpha$ -> $\alpha$!,
We read this type as follows: for all types, !$\alpha$!, if the argument is of type !$\alpha$!
then the function returns a value of type !$\alpha$!.
We also need to tame unconstrained polymorphism.
A division function on all types does not make sense. We cannot
divide a function that multiplies two numbers by a function that adds two numbers.
The type !$\forall$ $\alpha$. ($\alpha$ $\times$ $\alpha$) -> $\alpha$!, that accepts
a pair of values of type !$\alpha$!, and returns the first component divided by the
second component is too general to describe division. A constrained polymorphic type,
!$\forall$ $\alpha$. (Dividable $\alpha$) => ($\alpha$ $\times$ $\alpha$) -> $\alpha$!,
more accurately describes the functions intention. Intuitively, the predicate,
!Dividable $\alpha$!, means: only those types that satisfy this predicate
have a meaningful divide function. Typeclasses\cite{wadler_polymorphism_1989} give a mechanism
of having such constrained polymorphic types. Theory of qualified types\cite{jones_qualified_1994}
formalizes typeclasses and justifies constrained polymorphism
without compromising type safety by having predicates as a part of type syntax.

A typeclass also defines relations on types. This gives programmers a way to
encode computations at type level. However, using relations to encode type computations
is cumbersome. A new language feature, type families\cite{schrijvers_towards_2007}, was introduced in Haskell
to enable type functions. They are stylistically more obvious for functional programmers.
Naturally, type families warrants a richer system of types and ensuring type safety
for such a language is nontrivial.

\TODO{rework this at the end}
The scope of the current article is as follows:
we first give examples and intuitive set semantics for typeclasses in the beginning of \pref{sec:tc},
and then describe functional dependencies\cite{jones_tcfd_2000} with some examples in \pref{sec:fd}.
We formalize them in \pref{subsec:tc-formal} and describe their consequences % of introducing
% functional dependencies by improving type inference and detecting ambiguous types
in \pref{subsec:fd-improve}.
We also give a brief description of type safety for this system in \pref{subsec:tcfd-safety}.
We then describe two flavors of type families---closed type families\cite{eisenberg_typefamilies_2014}
in \pref{sec:tf-closed} and  constrained type families\cite{morris_typefamilies_2017}
in \pref{sec:tf-constrained} with examples and their respective formalization in \pref{subsec:tf-closed-formal}
and \pref{subsec:tf-constrained-formal}. We then give some details about the type safety of
each system in \pref{subsec:tf-closed-safety} and \pref{subsec:tf-constrained-safety} respectively.
To conclude we % give some related work in \pref{sec:related-work}, and 
draw some comparisons between the three systems while pointing towards some open questions in \pref{sec:conclusion}.
To be concrete about the examples we will use a Haskell like syntax.

\section{Typeclasses}\label{sec:tc}
Typeclasses can be thought of as collection of types. Each typeclass is accompanied by its member
functions that all the instances ought to support. For example,
equality can be expressed as a typeclass !Eq a! as follows:\newline
{
  \footnotesize
  \begin{tabularx}{\textwidth}{X X X}
\begin{code}^^J
class Eq a where^^J
\ \ (==) :: a -> a -> Bool^^J
\end{code}&%
\begin{code}^^J
instance Eq Int where^^J
\ \ a == b = primEQInt a b^^J
\end{code}&%
\begin{code}^^J
instance Eq Char where^^J
\ \ a == b = primEQChar a b^^J
\end{code}
  \end{tabularx}
}
The instances of !Eq! typeclass can be types such as integers (!Int!) and characters (!Char!) but
defining equality on function types (!a->b!) is not meaningful. The operator
!(==)! is not truly polymorphic: it cannot operate on function types. Rather
it is constrained to only those types that have an !Eq! instance defined.
We make this explicit in the type of the operator !(==)!, by saying it's defined
only on those types !a! that satisfy the !Eq a! predicate,
or !(==) :: $\forall$a. Eq a => a -> a -> Bool!. The reading for this type is: for any type !a! that
satisfies the predicate !Eq a!, if we are given two
values of type !a!, then we can return a Boolean value indicating if the two arguments are equal.

%% What are these?
There is nothing special about typeclasses having just one type parameter. 
A multiparameter typeclass with $n$ type parameters represents a relation on $n$ types.
An example of such a typeclass, !Add a b c! is shown in \pref{fig:multip-typeclass}.
It represents a relation of types !a!, !b! and !c! such that adding values of type !a! and type !b!
gives us a value of type !c!. The type of the operator, !(+)!, that performs this add operation will be
!$\forall$a b c. Add a b c => a -> b -> c!. Instances of such a typeclass would be !Add Int Int Int!,
!Add Int Float Float!, and so on.
\begin{figure}[ht]
  \footnotesize
  \begin{tabularx}\textwidth{c c c}
\begin{code}^^J
class Add m n p where^^J
\ \ (+) :: m -> n -> p^^J
\end{code}&%
\begin{code}^^J
instance Add Int Float Float where^^J
\ \ (+) a b = addFloat (toFloat a) b^^J
\end{code}&%
\begin{code}^^J
instance Add Int Int Int^^J
\ \ (+) a b = intAdd a b^^J
\end{code}
  \end{tabularx}
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
instance Add Int Float Int where^^J
\ \ (+) a b = addInt a (toInt b)^^J
\end{code}&%
\begin{code}^^J
expr :: (Add Int Float b, Add b Int c) => c^^J
expr = (1 + 2.5) + 3^^J
\end{code}
  \end{tabularx}
  \caption{Multiparameter Typeclasses}
  \label{fig:multip-typeclass}
\end{figure}

%% What problems do they introduce?
Multiparameter typeclasses, however, are difficult to use in practice.
Suppose the programmer defines two instances: !Add Int Float Float! and !Add Int Float Int!
and writes an term !expr = (1 + 2.5) + 3!.
Due to the use of the operator !(+)! in !expr!, its most general type synthesized
by the type inference algorithm will be !$\forall$ b c. (Add Int Float b, Add b Int c) => c!.
Notice how the type variable !b! occurs only in the predicate set !(Add Int Float b, Add b Int c)!.
Such types are called ambiguous types and the type variables, such as !b!,
are called ambiguous type variables. Ambiguous types do not have well defined semantics in Haskell.
The compiler cannot choose a unique interpretation of the subterm !(1 + 2.5)! as it can very well be
of the value !4! of type !Int! or the value !2.5! of type !Float!.
Haskell, thus, disallows ambiguous types by reporting a type error.
However, the type errors can cause confusion; although the issue can be attributed to
conflicting instances of typeclass !Add m n p!, the type error is raised at the term which may
be defined in a different location.

\section{Functional Dependencies with Examples}\label{sec:fd}
%% How does this solve the previous problem
Typeclasses with functional dependencies\cite{jones_tcfd_2000} is a generalization of multiparameter typeclasses.
It introduces a new syntax where the user can specify a dependency between the type parameters
in the typeclass declaration. There is no change in the syntax of declaring instances.
!Add m n p! typeclass, as shown in \pref{fig:add-tc-fd}, now has a functional dependency
between the type parameters such that types !m! and !n! determine the type !p!.
In general we can have multiple parameters on both sides of the arrow,
(!$x_1$, ..., $x_m$ -> $y_1$, ..., $y_m$!). We write !X -> Y! to mean
``the parameters \texttt{X} uniquely determine the parameters \texttt{Y}''.

\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{l l}
\begin{code}
class Add m n p | m n -> p where
  (+) :: m -> n -> p
\end{code}&%
\begin{code}
instance Add Int Float Float where
  $\ldots$
\end{code}\\
    &
\begin{code}
instance Add Int Float Int where -- Error!
  $\ldots$
\end{code}
  \end{tabular}
  \caption{\texttt{Add m n p} with Functional Dependency and Conflicting Instances}
  \label{fig:add-tc-fd}
\end{figure}

The programmer can use functional dependencies to specify the intention of the typeclasses
more accurately, and in turn it gives the compiler a way to detect and report inconsistent instances.
For example, the functional dependency on !m n -> p!
can now help the typechecker flag the instance !Add Int Float Int! to be in conflict with the instance
!Add Int Float Float! which was indeed the real intention of the typeclass.

Further, we may also be able to determine the ambiguous type variables using the functional dependencies.
Let's reconsider the ambiguous type of term !e! from the previous section, we can now determine
that !b! has to be !Float!. It is determined by the types !Int! and !Float! of the class instance.
Thus, !expr :: (Add Int Float Float, Add Float Int c) => c!.
We can even go a step further and improve this seemingly polymorphic type.
The type variable !c! can be determined to be !Float!, giving us the type !expr :: Float!.
It would be impossible to make such an improvement without the functional dependency.

\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{l l}
\begin{code}
data Z   -- Type level Zero
data S n -- Type level Successor
\end{code}&%
\begin{code}
class IsPeano c
instance IsPeano Z
instance IsPeano n => IsPeano (S n)
\end{code}\\
\begin{code}
class Plus m n p | m n -> p
instance IsPeano m => Plus Z m m
instance Plus n m p => Plus (S n) m (S p)
\end{code}&%
\begin{code}
data Vector s e = Vec (List e)
concat_vec :: Plus m n p
     => Vector m e -> Vector n e -> Vector p e
concat_vec (Vec l1) (Vec l2) = Vec (append l1 l2)
\end{code}
  \end{tabular}
  \caption{Peano Arithmetic and Vector Operations with Functional Dependencies}
  \label{fig:peano-arith}
\end{figure}

With functional dependencies at our disposal, we can even perform Peano arithmetic at type level,
as shown in \pref{fig:peano-arith}. The two datatypes !Z! and !S n!
represent the number zero and successor of a number !n!, respectively.
The instances of !IsPeano! assert that: !Z! is a peano number, and if !n! is a peano number
then !S n! is a Peano number. The instances of !Plus! typeclass relates three peano numbers such that the relation
holds if the first two peano numbers add up to be equal to the third. Thus, !Peano Z m m! asserts the relation
!0 + m = m!, and !Plus n m p => Plus (S n) m (S p)! asserts that if n + m = p then (1 + n) + m = (1 + p).
The !concat_vec! function demonstrates why type level computation would be useful
for a linear algebra library. The type of !concat_vec! says that the size of the resulting
vector is the sum of the sizes of the argument vectors.
The above examples are meant to demonstrate how functional dependencies help in encoding
type level functions that multiparameter type classes cannot not due to absence of the capability
to restrict the class relation that the programmer needs.

\subsection{Formalizing Typeclasses with Functional Dependencies}\label{subsec:tc-formal}
% \TODO{start here. Why do we need to formalize? how should incoherence/ambiguity be formalized? How does functional
%   dependency prevent that?}
In previous sections we made a case for why ambiguous types are problematic and how
functional dependencies can help us solve it. We now formalize this intuition to make our claim precise.
We organize the our language as shown in \pref{fig:tcfd-syntax} and call it \TCFD.
The types ($\tau$) consist of type variables ($\alpha$), functions ($\tau\to\tau$), and type constants
($\TypeCtrs$) such as !Int!, !Float! etc. The qualified types ($\rho$) are $\Preds\then\rho$
where $\Preds$ constrains the type $\rho$. Type schemes ($\sigma$) are quantified constraint types.
The terms or expressions in the language ($\Tm$) consists term level variables ($x, y$),
functions ($\Lam x \tau e$), function applications ($e_1\App e_2$).

\begin{figure}[ht]
    \small
  \[
  \begin{array}{l l l}
    &\text{Type Variables}     &\alpha, \beta\\
    &\text{Term Variables}     &x, y\\
    &\text{Class Constructors} &\ClassCtrs\\
    &\text{Type Constants}  &\TypeCtrs\\    
    \\
    &\text{Term Typing}        &\QTyping \Preds \TEnv \Tm \tau\\
  \end{array}
  \begin{array}{l l l l}
    &\text{Predicates}      &\pi               &\bnfeq C\many{\tau}\\
    &\text{Predicate Set}   &\Preds,\MorePreds &\bnfeq \many\pi\\
    &\text{Types}           &\tau              &\bnfeq \alpha \bnfor \tau\to\tau \bnfor \TypeCtrs\\
    &\text{Qualified Types} &\rho              &\bnfeq \tau \bnfor \Preds\then\tau\\
    &\text{Type Schemes}    &\sigma            &\bnfeq \forall{\many\alpha}.\rho\\
    &\text{Terms}           &\Tm               &\bnfeq x \bnfor \Tm\App\Tm \bnfor \Lam x \tau \Tm\\
    &\text{Values}          &\val              &\bnfeq \Lam x \tau \Tm
    \\
    &\text{Typing Environment} &\TEnv &\bnfeq \empt \bnfor \TEnv,x\co\sigma
  \end{array}
  \]
  \caption[\TCFD]{\TCFD}
  \label{fig:tcfd-syntax}
\end{figure}

\subsubsection {Notations}\label{subsubsec:tcfd-notations}
We will use notations as follows. Subscripts on objects
($\alpha_1,\ldots, \alpha_n$) are used to distinguish them.
A collection of $\alpha_1, \alpha_2, ..., \alpha_n$ items of arbitrary length is written as $\many\alpha$
We use $S_1 \setdiff S_2$ to denote the set difference operation. For an object $X$,
$\TV{X}$ is the set of type variables that are free in $X$.
We write $[\many{x}\mapsto\many{y}]\Tm$ to denote the substitution where each variable
$x_i$ is mapped to $y_i$ in $\Tm$. Alternatively, we also
write $\Subst X$ for an substitution $\Subst$ applied to object $X$.
We denote the most general unifier for two types $\tau_1$ and $\tau_2$ (if it exists),
by $\mgu{\tau_1}{\tau_2}$\cite{robinson_machine-oriented_1965}.
We write $\mgu{\many{\tau_1}}{\many{\tau_2}}$ to give us a composition of most general
unifier for each pair of types $(\tau_{1i}, \tau_{2i})$.
% We abbreviate the $\ClassCtrs\many\alpha$ as $\Preds$ and $\MorePreds$

For a typeclass declaration we write !class $\Preds$ => $\ClassCtrs$ t!, where !t! are the type parameters
of the class and $\Preds$ are the constraints that must be satisfied, and for an instance of typeclass
$\ClassCtrs$, we write !instance $\Preds$ => $\ClassCtrs$ t!, where length of !t!
matches the typeclass arity with additional constraints on !t! are introduced by $\Preds$.
We denote the set of functional dependencies of class !C! with $\FunDep{C}$.
For an arbitrary functional dependency !$X$ -> $Y$! the determinant of a functional dependency
is denoted by $t_{X}$ and the dependent is denoted by  $t_{Y}$.
For example, for a typeclass declaration !class Add m n p | m n -> p!,
we have, $t = (m, n, p)$, $\FunDep{Add}=$!$\{$ m n -> p $\}$!.
For the functional dependency !m n -> p!, we have, $t_X = {(\texttt{m},\texttt{n})}$ and $t_Y = {(\texttt{p})}$.
Given a set of functional dependencies $\texttt{J}$, we define the closure operation,
$\closure Z {\texttt{J}}$, on $Z \subseteq t$, to be equal to all the type parameters
that are determined by set of the functional dependencies \texttt{J}.
Thus, $\closure {\Set{m}} {\FunDep{Add}} = \Set{m}$ and $\closure {\Set{m, n}} {\FunDep{Add}} = \Set{m, n, p}$.

\subsubsection{Type System}\label{subsubsec:tcfd-system}
The typing environment $\TEnv$ is a mapping between term variables to types
such that a term variable appears at most once. We write $\dom{\TEnv}$ to mean
the set of all term variables in $\TEnv$ i.e. $\Set{x \mid (x\mapsto\tau) \in \TEnv}$.
We denote $\TEnv_x$ to be $\TEnv$ obtained after removing the binding for $x$ (if it existed) in $\TEnv$.
The typing judgements are of the form $\QTyping \Preds \TEnv \Tm \sigma$.
They assert existence of a typing derivation that shows $\Tm$ has type $\sigma$
with predicates $\Preds$ being satisfied and the free variables in $\Tm$
are given types by the typing environment $\TEnv$.
The typing rules that build these typing derivations in our system are shown
in \pref{fig:tcfd-typing} that we will go over next.
\newcommand\TPAbs{
  \ib{\irule[\trule{$\I\then$}]
    {\QTyping {\Preds,\MorePreds} \TEnv \Tm \rho};
    {\QTyping \Preds \TEnv \Tm {\MorePreds\then\rho}}}
}

\newcommand\TPApp{
  \ib{\irule[\trule{$\E\then$}]
    {\QTyping \Preds \TEnv \Tm {\MorePreds\then\rho}}
    {\ent \Preds \MorePreds};
    {\QTyping \Preds \TEnv \Tm \rho}}
}

\newcommand\TAbs{
  \ib{\irule[\trule{$\I\to$}]
    {\QTyping \Preds {\TEnv_x, x\co\tau_1} {\Tm} {\tau_2}};
    {\QTyping \Preds \TEnv {\Lam x {\tau_1} \Tm} {\tau_1 \to \tau_2}}}
}
 
\newcommand\TApp{
  \ib{\irule[\trule{$\E\to$}]
    {\QTyping \Preds \TEnv {\Tm_1} {\tau_2 \to \tau}}
    {\QTyping \Preds \TEnv {\Tm_2} {\tau_2}};
    {\QTyping \Preds \TEnv {\Tm_1\App\Tm_2} {\tau}}}
}

\newcommand\TVar{
  \ib{\irule[\trule{var}]
    {x\co\sigma \in \TEnv};
    {\QTyping {\Preds} {\TEnv} {x} {\sigma}}}
}

\newcommand\TForallI{
  \ib{\irule[\trule{$\I\forall$}]
    {\QTyping \Preds \TEnv \Tm \rho}
    {\alpha\not\in\TV\TEnv \cup \TV\Preds};
    {\QTyping \Preds \TEnv \Tm {\Forall{\alpha}\rho}}
  }
}

\newcommand\TForallE{
  \ib{\irule[\trule{$\E\forall$}]
    {\QTyping \Preds \TEnv \Tm {\Forall\alpha\rho}}
    {\beta~\text{fresh}};
    {\QTyping \Preds \TEnv \Tm {[\alpha\mapsto\beta]\rho}}
  }
}

\begin{figure}[ht]
  \centering
  \small
  \[
    \begin{array}{c}
      \TVar \\
      \TAbs \\
      \TApp \\          
    \end{array}
    \begin{array}{c}
      \TForallI\\
      \TForallE\\
      \TPAbs\\   
      \TPApp\\   
    \end{array}
  \]
  \caption{Typing judgments for \TCFD{} Terms}
  \label{fig:tcfd-typing}
\end{figure}

The left column lists the standard term typing rules.
Each term is associated with one typing rule that specifies when the term is well typed.
The rule \trule{var} says that if the variable $x$ has type $\sigma$ then
typing environment $\TEnv$ should contain that binding to confirming.
The rule \trule{$\I\to$} says that if a term, $\Tm$, has type $\tau_2$
with a free variable $x$ of type $\tau_1$ then the term $\Lam x {\tau_1} \Tm$
has a type $\tau_1 \to \tau_2$. The rule \trule{$\E\to$} justifies function application
that says if a term (function) $\Tm_1$ is of type $\tau_1 \to \tau_2$
and another term (argument) $\Tm_2$ is of type $\tau_2$, then the term $\Tm_1\App\Tm_2$ is of type $\tau_2$.

The right column contains rules that involve the predicate set of the typing judgement.
The rule \trule{$\I\forall$} generalizes the type and the rule \trule{$\E\forall$} instantiates it.
It is necessary for $\beta$ to be a fresh type variable to ensure it doesn't clash with
existing free type variables. The rule \trule{$\I\then$} moves the global predicate $\MorePreds$
in to constrain the type $\rho$ while the \trule{$\E\then$} moves the constraint
out of the type $\rho$. The condition $\Preds\entails\MorePreds$,
read as ``$\Preds$ entails $\MorePreds$'', means that
whenever $\MorePreds$ is satisfied $\Preds$ is also satisfied.
\TODO{entailment relation properties}
\subsection{Improving Substitution and Ambiguous Types}\label{subsec:fd-improve}
The typing rules shown in \pref{fig:tcfd-typing} does not included the use of functional dependencies.
We will now formalize it using an extra typing rule \trule{impr} that we motivate below.

\newcommand\Impr{
  \ib{\irule[\trule{impr}]
    {\QTyping \Preds \TEnv \Tm \rho}
    {\Subst = \impr \Preds};
    {\QTyping {\Subst\Preds} {\Subst\TEnv} \Tm {\Subst\rho}}
  }
}
$$
\Impr
$$
% \TODO{Check the impr rule}
An improving substitution, written as $\impr\Preds$, is a substitution that does
not change the set of satisfiable instances of predicate set $\Preds$. 
The rational behind improving substitution is that it helps simplifying
the type by showing its true and concise characterization.
Computing an improving substitution in our case is to find if any of the type variables
can be determined using the functional dependency given in the predicate set.
For each functional dependency, !X -> Y!, induced by the predicate set, $\Preds$, or
$(X \to Y)\in\FunDep{P}$, for a particular class $\texttt{C t} \in \Preds$,
whenever we know $\TV{t_X}$, then we can determine $\TV{t_Y}$.
For example, consider the type of !expr :: (Add Int Float b, Add b Float c) => c!.
The improvement is done using the functional dependency
$\FunDep {Add} = \Set{\texttt{m n} \to \texttt{p}}$ to obtain an improving substitution
$[b\mapsto\texttt{Float}, c\mapsto\texttt{Float}]$.

We can also modify detection of ambiguous types.
For a qualified type, $\forall\many{\alpha}.\Preds\then\tau$, the usual ambiguity
check is $(\many{\alpha}\cap\TV{P}) \subseteq \TV{\tau}$. However,
with induced functional dependencies $\FunDep P$ due to $\Preds$,
the appropriate check would be $(\many{\alpha}\cap\TV{P})
\subseteq \closure {\TV{\tau}} {\FunDep \Preds}$. We thus weaken the check
as there can be some type variables which are determined
by the functional dependencies induced by the class constraints.
% An improving substitution can very well be a trivial identity substitution
% when there are no type variables to improve on.
% Computing it may also fail which would mean that we have a predicate
% set that is unsatisfiable and the term can be flagged as an illtyped term.

%% How can one detect inconsistent class instances in the formalization
\subsection{Instance Validity and Inconsistency Detection}
Every typeclass introduces a new realtion on types. With functional dependencies,
we have additional constraints which every instances should satisfy.
We need to ensure that the instances declared are compatible
with the functional dependencies associated with the typeclass.
There are two necessary conditions to ensure this:
\begin{enumerate}[topsep={0pt},partopsep={0pt}]
\item\emph{Covering Condition}:  For each new instance declaration !instance $\Preds$ => C t where ...!
  that the programmer writes, we need to check that,% , for each functional dependency
  $\TV{t_Y} \subseteq \closure{\TV{t_X}}{\FunDep{{P,C}}}$,
  where $\FunDep{{P,C}}$ are the functional dependencies of $C$ and additional dependencies
  induced by the instance context $P$. Intuitively, this condition says that
  all the type variables of the dependent, $\TV{t_Y}$, should either already be in the
  set of determinant type variables, $\TV{t_X}$, or they should be fully determined using the
  functional dependencies induced by the class ($\FunDep{C}$) or the functional dependencies
  induced by the constraints ($\FunDep{P}$). For example, for a typeclass declaration
  !class C a b |  a -> b! the instance declaration !instance C Int a! fails the coverage test,
  while !instance C a Int! passes it.
\item\emph{Consistency Condition}: For each new instance of the form !instance $\MorePreds$ => C s where ...!
  along with !instance $\Preds$ => C t where ...! we need to ensure whenever $t_Y = s_Y$ we also have $t_X = s_X$.
  It is straightforward to check this condition. We first find the most general unifier for $t_X$ and $s_X$,
  say $U=\mgu {t_X}{s_X} $, and then check that $U t_Y = U s_Y$. If we cannot find such a unifier, then we know that
  the instances are consistent. For example, !instance C1 Int a! is consistent with !instance C1 Char a!
  as there is no unifier for !Int! and !Char!. However, !instance Add Int Float Float!
  and !instance Add Int Float Int! are inconsistent.% with an identity unifier.
\end{enumerate}

\section{Associated Types}\label{sec:assoc-types}
Another way to express type computation is by having the typeclass with
a special associated type\cite{chakravarty_associated_2005}.
In this style, each instance of the typeclass specifies how the associated type should be interpreted.
For example, Peano arithmetic can be expressed using !PlusC m n! typeclass with an associated type
!Plus m n! as shown in \pref{fig:plus-assoc-type}.
\begin{figure}[ht]\centering
  \footnotesize
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
class PlusC m n where^^J
\ \ type Plus m n^^J
^^J
instance PlusC Z n where^^J
\ \ type Plus Z n = Z^^J
\end{code}&%
\begin{code}^^J
instance PlusC m n => PlusC (S m) n where^^J
\ \  type Plus (S m) n = S (Plus m n)^^J
^^J
concat_vec :: Vec m e -> Vec n e^^J
\ \ \ \ \ \ \ \-> Vec (Plus n m) e^^J
\end{code}
  \end{tabularx}
  \caption{Plus as an Associated Type}
  \label{fig:plus-assoc-type}
\end{figure}

The type !Plus m n! has two interpretations due to the two typeclass instances,
!Plus Z n  = Z! means $0 + n = 0$, while !Plus (S m) n = S (Plus m n)! means $(1 + m) + n = 1 + (m + n)$. 
The associated type can be viewed as a type function; depending on the use context
one of the interpretations would be picked.
The type of !concat_vec! changes as !Plus n m! is now a type.
We no longer specify it in the predicate set of the type as it does not have a relational style reading.
As visible from the code snippet, attractiveness of this style is that type computation is
no longer limited in the predicates.

An enthusastic programmer might now try write type equality
using a typeclasses with an associated type as shown below.
We use !TT! and !FF! to represent type level true and false respectively while
the associated type !TEq a b! will be used to compute if the two types !a! and !b! are equal.

{\footnotesize\centering
  \begin{tabularx}\textwidth{X X X}
% \begin{code}^^J
% data TT -- True^^J
% data FF -- False^^J
% \end{code}&%
\begin{code}^^J
class TEqC a b where^^J
\ \ type TEq a b^^J
\end{code}&%
\begin{code}^^J
instance TEqC a a where^^J
\ \ type TEq a a = TT^^J
\end{code}&%
\begin{code}^^J
instance TEqC a b where -- Error^^J
\ \ type TEq a b = FF^^J
\end{code}
  \end{tabularx}
}\\
To the programmers disappointment this definition is rejected by the type system.
The presense of both instances !TEqC a a! and !TEqC a b! is conflicting due to their overlap.
Two instances overlap when both instances provide a match while resolving a constraint.
For example, both the instances !TEqC a a! and !TEqC a b! can be used to match the constraint
!TEqC Int Int!. There is no way for the compiler to choose one instance over the other.
Haskell rejects programs that have overlapping instances as it assumes
that there can only be a unique typeclass instance that matches the constraint.

\section{Closed Type Families}\label{sec:tf-closed}
Closed type family is a generalization of associated typeclasses. We notice from
the above !PlusC m n! typelcass example that we could separate out the associated type !Plus m n!
into its own entity and collect each of its type equations defined by the instance together as shown below.
{\footnotesize
\begin{tabularx}\textwidth{X X X}
&\begin{code}^^J
type family Plus n m where^^J
\ \ Plus Z     m = m^^J
\ \ Plus (S n) m = S (Plus n m)^^J
\end{code}&
\end{tabularx}
}

We call this declaration a type family as it can be thought of as a family of types indexed by the type parameters.
In our case, the type family !Plus m n! has two equations, each corresponding to the two, previously
discussed, instances of the typeclass. This style of writing type functions is palatable
for functional programmers. It resembles a familiar notion of writing term level equations with pattern matching.
\begin{figure}[ht]
\centering\small
\begin{tabularx}{\textwidth}{X X}
\begin{code}^^J
type family Result m n where^^J
\ \  Result Int   Int = Int^^J
\ \  Result a     Float = Float^^J
\ \  Result Float a = Float^^J
^^J
class Add m n where^^J
\ \  (+) :: m -> n -> Result m n^^J
^^J
instance Add Int Int where^^J
\ \  (+) = intAdd^^J
\end{code}&%
\begin{code}^^J
instance Add Int Float where^^J
\ \  i + f = addFloat (int2Float i) f^^J
^^J
instance Add Float Int where^^J
\ \  f + i = addFloat (int2Float i) f^^J
^^J
instance Add Int Float where -- Error^^J
\ \  i + f = addInt i (float2int f)^^J
\end{code}
\end{tabularx}
\caption{\texttt{Add} Typeclass using Closed Type Family}
\label{fig:add-ty-fam}
\end{figure}
The !Add m n p! typeclass defined in \pref{fig:add-tc-fd} can also be written in
a closed type family style as shown in \pref{fig:add-ty-fam}. The change is that the new 
!Add! typeclass takes only two parameters in this setting while the result type
of !(+)! function now returns a special type !Result m n!. This !Result m n! type is defined
for each instance we expect the typeclass !Add! to be defined at.
The second typeclass instance !Add Int Float! would raise a type error due to
its overlap with the first typeclass instance. Even if the compiler did accept overlapping
instances, the expected type of the operator !(+)! will not match the type of the term; the type 
!Result Int Float! always reduces to type !Float!.
% We will write $\stepsto{\tau_1}{\tau_2}$ to mean
% the type $\tau_1$ reduces to $\tau_2$, for example, !Result Int Float $\rightsquigarrow$ Float!
\subsection{Type Matching, Apartness and Reduction}\label{subsec:tf-closed-apartness}
The role of type famlies is to compute the representation type by instantiating the type indices during
type checking phase. In the !Add! example, the representation type of !Result Int Float!
is !Float! while, the representation type of !Plus Z m! is !Z!. The semantics of equations has certain subtleties.
Reduction an occurance of a type family in a type signature is done using a top to bottom matching technique.
The first equation that matches is used, or fired, for reduction. For example, the type !Add Float Float! matches with the
second equation !Add a Float!---!Int! and !Float! don't match---to reduce to !Float!.
The substitution $[a\mapsto\texttt{Float}]$, which does the trick,
can be computed using the most general unifier function $\mgu {a} {\texttt{Float}}$.\\
{\footnotesize
  \begin{tabularx}{\textwidth}{X X X}
&\begin{code}^^J
type family TEq a b where^^J
\ \ TEq a a = TT^^J
\ \ TEq a b = FF^^J
\end{code}&%
\end{tabularx}
}\\
The real advantage of closed type families over associated types,
is the ability to express type functions that were previously not possible
such as !TEq a b! as shown above. Fixing the order of equation matching
liberates us from the restriction of having non-overlapping equations;
the type !TEq Int Int! will be matched with the first equation.

Now, let us consider the function !funTrick!, as shown in \pref{fig:closed-tf-tricky}.
The type !Tricky a! matches the second equation and reduces to !Bool!.
This reduction will, however, can crash the program, !$\text{\faBomb}$!, which uses !funTrick!
and instantiates !d! to !Bool!, and !Tricky Bool! in turn reduces to !Int -> Int!.
Type soundness bugs, which cause runtime crashes, can be introduced while using overlapping equations
and a na\"ive type reduction strategy. We need to identify the necessary conditions to use
type reductions and ensure type soundess.
\begin{figure}[ht]
  \small
  \begin{tabularx}\textwidth{X X X} 
\begin{code}^^J
type family Tricky a where^^J
\ \ Tricky Bool = Int -> Int^^J
\ \ Tricky a    = Bool^^J
\end{code}&
\begin{code}^^J
funTrick :: a -> Tricky a^^J
funTrick _ = True^^J
\end{code}&
\begin{code}^^J
$\text{\faBomb}$ :: Int^^J 
$\text{\faBomb}$ = funTrick True 5^^J
\end{code}
\end{tabularx}
  \caption{Unsoundess due to Tricky Type Family}
  \label{fig:closed-tf-tricky}
\end{figure}

Due to term rewriting systems literature\cite{bezem_term_2003}, a necessary condition for type soundness
with type reduction is to have confluence. If a type has multiple ways of reducing,
it should not matter what way we choose, we should obtain the same final type. %apologies to robert frost.
Indeed, in the above example, we did see a consequence of non-confluence, one way of reduction
gave us !Int -> Int! while the the other gave us !Bool!.
We fix this behavior by incorporating flattening and apartness into the type reduction criteron.
%% Motivate type flattening for matching
First we fix our notion of matching:
\begin{defn}[Matching]\label{def:ctf-match}
  We say a type $\tau$ matches $\sigma$ if there is a substitution $\Subst$ such that $\Subst\tau \teq \sigma$ with
  $\dom\Subst \subseteq \TV\tau$.
\end{defn}
We use $\tau_1 \teq \tau_2$ to remind us that $\tau_1$ and $\tau_2$ are equal in the sense
of propositional equality rather than definitional equality.
\begin{defn}[Type Flattening]\label{def:ctf-flatten}
  We say a type $\tau$ is flattened to $\tau_1$, or $\tau_1 = \flatten{\tau}$, when, every
  type family application of the from $\FamCtrs(\many\sigma)$ in $\tau$,
  if $\sigma$ of the form $\FamCtrs'(\many\sigma')$ it is replaced by a type variable,
  such that in the flattened type, every syntactically equivalent type family application
  in $\tau$ is replaced by same type fresh type variable
  and syntactically different type family applications in $\tau$ are replaced by distinct fresh type variables.
\end{defn}
\begin{defn}[Apartness]\label{def:ctf-apart}
  For an equation, say $p$, and a type, say $\tau$, $p$ is apart from $\tau$, if 
  or we cannot find a most general unifier that unifies both the left hand side of the equation
  and the flattened type of $\tau$, or $\mgu{\lhs p}{\flatten\tau}$ fails.
\end{defn}
Finally, the equation selection criterion for type reduction can be defined follows:
\begin{defn}[Closed Type Family Reduction Criteron]\label{def:cft-simpl-1}
  An equation, say $p$, given in the type family declaration can be used to simplify the type
  $\FamCtrs(\many\tau)$, if the following two conditions hold:
  \begin{enumerate}
  \item The left hand side of the equation, $\lhs p$  matches the the type $\FamCtrs(\many\tau)$
    or $\match{\lhs p}{\FamCtrs(\many\tau)}$.
  \item All equations, $q$, preceding $p$, are apart from $\FamCtrs(\many\tau)$, or
    $\apart {q} {\FamCtrs(\many\tau)}$.
  \end{enumerate}
\end{defn}
Let us reconsider the type !a -> Tricky a!, with the above definition of type familiy reduction.
Now, !Tricky Bool! does not match !Tricky a!, as there is no substitution,
$\Subst$, such that $\Subst\texttt{Bool} \teq \texttt{Int}$.
However, !Tricky Bool! is not apart from !Tricky d!---the substitution $[d\mapsto\texttt{Bool}]$ does unify them,
hence we cannot use the second equation for type reduction; the second criteron from \pref{def:cft-simpl-1}
is not satisfied.
\begin{figure}[ht]
  \centering\small
  \begin{tabularx}\textwidth{X X X}
\begin{code}^^J
type family G a b where^^J
\ \ G Int Bool = Int^^J
\ \ G a   a    = Bool^^J
\end{code}&
\begin{code}^^J
type family F a where^^J
\ \ F Int    = Char^^J
\ \ F a      = Bool^^J
\end{code}&
\begin{code}^^J
G (F a) (F a)\ $\mathrel{\rightsquigarrow}$ Bool^^J
G (F a) (F b)\ $\mathrel{\not\rightsquigarrow}$ Bool^^J
\end{code}
  \end{tabularx}
  \caption{Type family Reduction Example}
  \label{fig:ctf-red-ex}
\end{figure}

Type flattening with sharing is necessary in apartness check to ensure type soundess.
For example, consider the type families shown in \pref{fig:ctf-red-ex},
if we have a type !G (F a) (F a)!, flattening the type would give us !G c c!,
and we will be able to match it with the second equation !G a a! and it will
be apart from !G Int Bool!. The type !G (F a) (F b)!, however, after flattening
becomes !G c d! and it is not apart from !G Int Bool!.

Simplification of type families by using apartness criterion will ensure soundness
but it has two shortcomings: 1) it is overly restrictive, and 2) it is inefficient due to the calls to unification.
We will illustrate them by using a couple examples: Consider second and third equations from !Add! type family,
!Add a Float = Float! and !Add Float a = Float!, and the type !Add Float b!, which we wish to reduce.
In this case, reduction of !Add Float b! to !Float! is not possible as the second equation is not apart
from !Add Float b!. But we know that both the equations reduce to the same final type, which is !Float!.
We call such equations conincident equations. We would like to allow such reductions as they will not
threaten soundness. Next, consider the equations of the !G a b! type family, !G Int Bool! and !G a a!.
It is easy to see that if any type matches !G a a! it will always be apart from !G Int Bool!, and
we can thus skip on the apartness check in such cases.

We can overcome on both the described shortcomings by using the notion of compatibility of equations defined below in
our reduction criteron.
\begin{defn}[Compatible Equations]\label{def:compact-eqns}
  Two equations, $p$ and $q$, are compatible   if and only if there exist two substitutions,
  say $\Subst_1$ and $\Subst_2$, such that if their application to the left hand sides of the equations
  equates them then the right hand sides after applying the respective substitutions also equates them.
  More succinctly, $\compat p q$ iff there exist substitutions $\Subst_1$ and $\Subst_2 $
  such that if $\Subst_1(\lhs{p}) = \Subst_2(\lhs{q})$ then $\Subst_1(\rhs{p}) = \Subst_2(\rhs{q})$.
\end{defn}
\begin{defn}[Closed Type Family Reduction Criteron Optimized]\label{def:cft-simpl}
  An equation, say $p$, given in the type family declaration can be used to simplify the type
  $\FamCtrs(\many\tau)$, if the following two conditions hold:
  \begin{enumerate}
  \item The left hand side of the equation, $\lhs p$  matches the the type $\FamCtrs(\many\tau)$
    or $\match{\lhs p}{\FamCtrs(\many\tau)}$.
  \item All equations, $q$, preceding $p$, are either apart from $\FamCtrs(\many\tau)$, or
    the equations are compatible. Symbolically, $\compat p q \lor \apart {\lhs q} {\FamCtrs(\many\tau)}$
  \end{enumerate}
\end{defn}
The two key insights here are that compatibility check loosens up the restriction
to enable type reductions without threatening soundess, and compatibility of equations
can be precomputed as it does not depend on the type we want to reduce and giving us a cheaper check
as compared to checking for apartness.

\subsection{Formalizing Type Soundess and Type Reduction}\label{subsec:tf-closed-formal}
In the previous section, we alluded that type soundess can be achieved using
confluence. In this section we will formalize it using \CLTF. The portion of the system necessary
to show type soundness is shown in \pref{fig:syntax-tf-closed}. We have special syntax category for
type family consructors ($\FamCtrs,\MoreFamCtrs$) along with the usual types. Predicates in this system
are type equalites $\tau_1\teq \tau_2$ asserts that types $\tau_1$ and $\tau_2$ are equal.
The axioms ($\Axiom\co\AxiomTy$) are a list of type family equations which are declared
along with the type family constructors. For example, the type family declaration !TEq a b! will
be represented in our system as
$\texttt{AxTEq}: [\forall\alpha.~{\texttt{TEq}~\alpha~\alpha} \teq \texttt{TT} , \forall\alpha\beta.~{\texttt{TEq}~\alpha~\beta} \teq \texttt{FF}]$.

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      &\text{Type family Constructors} & \FamCtrs,\MoreFamCtrs\\
      &\text{Type Constants} &\texttt{\TypeCtrs}\\      
      \\
      &\text{Type Validity}               &\ValidType \TEnv \tau\\
      &\text{Proposition Validity}        &\ValidProp \TEnv \Preds\\
      &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      % &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      % &\text{Context Validity}            &\ValidCtx\TEnv\\
      \\
      &\text{Type reduction}              &\tystepsto\GEnv\bullet\bullet
      % \\
      % &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      % &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      \\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau %\bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs\\% 
      &\text{Ground Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \TypeCtrs\\
      &\text{Predicates}      &\Preds       &\bnfeq \tau\teq\tau\\
      &\text{Type family Pattern}     &\texttt{\FamPattern} &\bnfeq \many\tau\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      % &\text{Coercions}  &\Co,\MoreCo &\bnfeq \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
      %                                   \bnfor \FamCtrs(\many{\Co}) \bnfor\TypeCtrs(\many{\Co})\\
      % &                  &            &\bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
      %                                   \bnfor \branch{i}{\many\tau} & \\
      % \\
      % &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
      %                                   \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau  \\
      % &                  &            & \bnfor \DataCtrs\many{e} \\
      % &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm\\
      \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom:\AxiomTy
                                        \bnfor \GEnv,\FamCtrs:n\\% \bnfor \GEnv,\TypeCtrs:n\\
      % &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,x\co\tau \bnfor \VEnv,\alpha\\
      % &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
      % \\
      % &\text{Type family Declaration} & & \texttt{\textbf{type family}}~
      %                                     \FamCtrs\App\many{\alpha}\texttt{\textbf{ where }}
      %                                     \many{F\App\FamPattern = \tau}
    \end{array}
  \]
  \caption[Excerpt \CLTF{}]{Excerpt of System for Closed Type Families (\CLTF)}
  \label{fig:syntax-tf-closed}
\end{figure}
% As the surface level language for GHC is too complex to formalize, we will formalize a small portion
% of interesting language constructs. The \CLTF has coercion types ($\Co,\MoreCo$), and 
% type family constructors ($\FamCtrs$) which are different from type constructors as they differ in their
% static semantics. The axiom equations define the type rewriting strategy for a specific $\FamCtrs$.
% For example, !TEq! type family looks like $\texttt{AxTEq}: [\forall\alpha.~{\texttt{TEq}~\alpha~\alpha} \teq \texttt{TT}
% , \forall\alpha\beta.~{\texttt{TEq}~\alpha~\beta} \teq \texttt{FF}]$.

% The typing judgments for terms in this system is a triple $\Typing\TEnv\Tm\tau$ that asserts that
% there is a derivation such that term $\Tm$ has type $\tau$ under the typing context $\TEnv$. All the interesting
% rules are given in \pref{fig:tf-closed-typing}. The typing environment ($\TEnv$) consists of two contexts,
% the variable context ($\VEnv$) which maps free variables to their types, and ground context ($\GEnv$)
% that stores all the type rewriting axioms and also necessary information for type and family constructors.
% The type validity judgments along with ground context and variable context validity are given
% in \pref{fig:tf-closed-validity}. They essentially walk over the context structures
% and ensuring we do not add anything invalid and check for type and axiom well formedness by making sure
% the context is consistent by using the goodness criterion described above.

% \newcommand\ValidTyVar{
%   \ib{\irule[\trule{v-tvar}]
%     {\alpha\in \VEnv}
%     {\ValidCtx{\GEnv;\VEnv}};
%     {\ValidType{\GEnv;\VEnv}\alpha}
%   }
% }
% \newcommand\ValidTyCtr{
%   \ib{\irule[\trule{v-tctr}]
%     {\TypeCtrs \co n \in \GEnv}
%     {\ValidCtx{\GEnv;\VEnv}}
%     {\many{\ValidType{\GEnv;\VEnv}{\tau_i}}^{i<n}};
%     {\ValidType {\GEnv;\VEnv}{\TypeCtrs\many\tau}}
%   }
% }
% \newcommand\ValidTFCtr{
%   \ib{\irule[\trule{v-tfctr}]
%     {\FamCtrs \co n \in \GEnv}
%     {\ValidCtx{\GEnv;\VEnv}}
%     {\many{\ValidType{\GEnv;\VEnv}{\tau_i}}^{i<n}};
%     {\ValidType {\GEnv;\VEnv}{\FamCtrs\many\tau}}
%   }
% }
% \newcommand\ValidTyArrow{
%   \ib{\irule[\trule{v-arr}]
%     {\ValidType \TEnv \tau_1}
%     {\ValidType \TEnv \tau_2};
%     {\ValidType {\TEnv}{(\tau_1\to\tau_2)}}
%   }
% }
% \newcommand\ValidTyFA{
%   \ib{\irule[\trule{v-tfa}]
%     {\ValidType {\GEnv;\VEnv,\alpha} \tau};
%     {\ValidType {\GEnv;\VEnv}{(\Forall\alpha\tau)}}
%   }
% }

% \newcommand\ValidEqProp{
%   \ib{\irule[\trule{v-eqp}]
%     {\ValidType \TEnv {\tau_1}}
%     {\ValidType \TEnv {\tau_2}};
%     {\ValidProp \TEnv {\tau_1\teq\tau_2}}
%   }
% }
% \newcommand\ValidTyFamProp{
%   \ib{\irule[\trule{v-tfp}]
%     {\FamCtrs\co n \in \GEnv}
%     {\many{\ValidType {\GEnv;\VEnv,\many\alpha} {N_i}}^{i<n}}
%     {\ValidType {\GEnv;\TEnv,\many\alpha} \sigma};
%     {\ValidProp {\GEnv;\VEnv} {\Forall{\many\alpha} {\FamCtrs(N) \teq \sigma}}}
%   }
% }

% \newcommand\ValidGndContextEmpt{
%   \ib{\irule[\trule{v-gempt}];
%     {\ValidGCtx\empt}
%   }
% }
% \newcommand\ValidGndContextTF{
%   \ib{\irule[\trule{v-gtf}]
%     {\fresh \FamCtrs \GEnv}
%     {\ValidGCtx\GEnv};
%     {\ValidGCtx{\GEnv,\FamCtrs \co n}}
%   }
% }
% \newcommand\ValidGndContextTC{
%   \ib{\irule[\trule{v-gtc}]
%     {\fresh \TypeCtrs \GEnv}
%     {\ValidGCtx\GEnv};
%     {\ValidGCtx{\GEnv,\TypeCtrs \co n}}
%   }
% }

% \newcommand\ValidGndContextAxiom{
%   \ib{\irule[\trule{v-gax}]
%     {\substack {\ValidGCtx\GEnv\\
%                \fresh \Axiom\GEnv}}
%     % {\substack {\many{\ValidType {\GEnv;\many{\alpha}_i} {N_i}}^{i<n}\\
%     % \many{\ValidType {\GEnv;\many{\alpha}_i} {\sigma_i}}^{i<n}}};
%     {\many{\ValidProp{\GEnv;\empt}{\Forall{\many\alpha}{\FamCtrs(\FamPattern)\teq\sigma}}}};
%     {\ValidGCtx{\GEnv,\Axiom\co\many{\Forall{\many\alpha}{\FamCtrs(\FamPattern)\teq\sigma}}}}
%   }
% }

% \newcommand\ValidVCtxtEmpt{
%     \ib{\irule[\trule{v-vempt}]
%     {\ValidGCtx\GEnv};
%     {\ValidVCtx\GEnv\empt}
%   }
% }
% \newcommand\ValidVCtxtTVar{
%   \ib{\irule[\trule{v-tyvar}]
%     {\ValidVCtx\GEnv\VEnv}
%     {\fresh\alpha\VEnv};    
%     {\ValidVCtx\GEnv{\VEnv,\alpha}}
%   }  
% }
% \newcommand\ValidVCtxtVar{
%   \ib{\irule[\trule{v-var}]
%     {\ValidVCtx\GEnv\VEnv}
%     {\fresh x \VEnv}
%     {\ValidType{\GEnv;\VEnv}\tau};
%     {\ValidVCtx{\GEnv}{\VEnv,x\co\tau}}
%   }    
% }

% \newcommand\ValidTyCtx{
%   \ib{\irule[\trule{v-te}]
%     {\ValidVCtx\GEnv\VEnv};
%     {\ValidCtx{\GEnv;\VEnv}}
%   }
% }

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%       \ValidTyVar & \ValidTyArrow & \ValidTyFA\\
%     \end{array}
%   \]
%   \[
%     \begin{array}{l l}
%       \ValidTyCtr & \ValidTFCtr\\      
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%       \ValidEqProp & \ValidTyFamProp
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c c c}
%       \ValidGndContextEmpt & \ValidGndContextTC & \ValidGndContextTF & \ValidGndContextAxiom
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c c c}
%       \ValidVCtxtEmpt  & \ValidTyCtx & \ValidVCtxtVar & \ValidVCtxtTVar
%     \end{array}    
%   \]
%   \caption{Validity Judgments}
%   \label{fig:tf-closed-validity}
% \end{figure}

% We show the interesting term typing rules in \pref{fig:tf-closed-typing} the rest are standard
% and we skip them due to space constraints, except the interesting one \trule{t-cast}.
% % As \CLTF is extension of \FC, we have two rules at term level, one for
% % type abstraction $\trule{t-tyabs}$ and another for type application $\trule{t-tyapp}$. These
% % rules are similar to previously described $\trule{t-abs}$ and $\trule{t-app}$ respectively
% % but describe type and term interaction.
% It says that a well typed term of type $\tau_1$ can be typed using a new type $\tau_2$
% if there is a welltyped witness $\Co$ that casts it from type $\tau_1$ to $\tau_2$.
% The three rules $\trule{co-refl}$, $\trule{co-sym}$, and $\trule{co-trans}$ say that the
% coercions form an equivalence relation. The four rules $\trule{co-arr}$, $\trule{co-type}$,
% $\trule{co-forall}$ and $\trule{co-fam}$ says that if two types are equal then each of
% their respective components are also equal, or that they form a congruence relation.
% The rules $\trule{co-ntharr}$ and $\trule{co-nth}$ says that we can decompose
% type qualities into simpler ones. The rule $\trule{co-inst}$
% says that if we have a witness that says two polytypes are equal, then we can obtain a witness
% where their respective instantiations with a type are also equal types.

\newcommand\TCast{
  \ib{\irule[\trule{t-cast}]
    {\CoTyping \TEnv \Co {\tau_1\teq\tau_2}}
    {\Typing \TEnv \Tm \tau_1};
    {\Typing \TEnv \Tm \tau_2}}}

\newcommand\TTyAbs{
  \ib{\irule[\trule{t-tyabs}]
    {\ValidType \TEnv \alpha}
    {\Typing {\TEnv,\alpha} \Tm \tau};
    {\Typing \TEnv {\TLam\alpha\Tm} {\Forall\alpha\tau}}}}

\newcommand\TTyApp{
  \ib{\irule[\trule{t-tyapp}]
    {\ValidType \TEnv {\tau_1}}
    {\Typing \TEnv \Tm {\Forall\alpha\tau}};
    {\Typing \TEnv {\Tm\App\tau_1} \tau[\tau_1/\alpha]}}}


\newcommand\CoArr{
  \ib{\irule[\trule{co-arr}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \sigma_1}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \sigma_2}};
    {\CoTyping \TEnv {\Co\to\MoreCo} {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}}}}

\newcommand\CoNthArr{
  \ib{\irule[\trule{co-ntharr$_i$}]
    {\CoTyping \TEnv \Co {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}};
    {\CoTyping \TEnv {\nth i \Co} {\tau_i \teq \sigma_i}}}}

\newcommand\CoForall{
  \ib{\irule[\trule{co-forall}]
    {\CoTyping {\TEnv,\alpha} \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\Forall\alpha\Co} {(\Forall\alpha\tau_1) \teq (\Forall\alpha\tau_2)}}}}

\newcommand\CoInst{
  \ib{\irule[\trule{co-inst}]
    {\ValidType\TEnv\tau}
    {\CoTyping {\TEnv} \Co {\Forall\alpha\sigma_1 \teq \Forall\alpha\sigma_2}};
    {\CoTyping \TEnv {\Co@\tau} {\sigma_1[\alpha/\tau] \teq \sigma_2[\alpha/\tau]}}}}
   
\newcommand\CoRefl{
  \ib{\irule[\trule{co-refl}]
    {\ValidType\TEnv\tau};
    {\CoTyping \TEnv {\refl{\tau}}:\tau\teq\tau}}}

\newcommand\CoSym{
  \ib{\irule[\trule{co-sym}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\sym{\Co}} {\tau_2\teq\tau_1}}}}

\newcommand\CoTrans{
  \ib{\irule[\trule{co-trans}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \tau_3}};
    {\CoTyping \TEnv {\comp \Co \MoreCo} \tau_1\teq\tau_3}}}

\newcommand\CoNth{
  \ib{\irule[\trule{co-nth}]
    {\CoTyping \TEnv \Co {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}};
    {\CoTyping \TEnv {\nth i {\Co}} {\tau_i\teq\sigma_i}}}}

\newcommand\CoTypeCtr{
  \ib{\irule[\trule{co-type}]
    {\TypeCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\TypeCtrs\many\Co} {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}}}}

\newcommand\CoFam{
  \ib{\irule[\trule{co-fam}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\FamCtrs\many\Co} {\FamCtrs\many\tau \teq \FamCtrs\many\sigma}}}}

\newcommand\CoAxiom{
  \ib{\irule[\trule{co-axiom}]
    {\substack {\AxiomTy = \many{\Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}}\\
               \Axiom\co\AxiomTy \in \GEnv}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\ValidCtx{\GEnv;\VEnv}};
    {\CoTyping {\GEnv;\VEnv} {\branch i {\many\tau}} {\FamCtrs (\FamPattern\many{[\alpha_i/\tau_i]}) \teq \sigma\many{[\alpha_i/\tau_i]}}}}}

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%     \TCast   % & \TTyAbs & \TTyApp
%     \end{array}
%   \]
%   \[  
%     \begin{array}{c c c}
%       \CoRefl & \CoSym & \CoTrans
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%       \CoArr     & \CoNthArr\\      
%       \CoTypeCtr & \CoNth\\
%       \CoForall  & \CoInst\\
%       \CoFam     & \CoAxiom
%     \end{array}
%   \]
%   \caption[Typing Judgments for \CLTF{}]{Typing Judgments \CLTF{}}
%   \label{fig:tf-closed-typing}
% \end{figure}

% The most interesting rule is the behemoth, $\trule{co-axiom}$ which gives conditions as to
% when we can use a particular coercion axiom to rewrite a type. In our example of !TEq!, there are two possible
% ways in which the axiom could have been instantiated:
% $\texttt{AxTEq}_0[\texttt{Int}]: \texttt{TEq  Int Int} \teq \texttt{TT}$
% or $\texttt{AxTEq}_1[\texttt{Int},\texttt{Int}]: \texttt{TEq Int Int} \teq \texttt{FF}$. But the second
% option would make the system unsound. The \noconflict{} check saves us from this disaster
% by allowing only the first option and rejecting the second.
% There are two ways in which the equations are in non-conflicting as shown in \pref{fig:tf-closed-nc}---
% 1) either the equations are compatible or 2) the equations are apart.

\newcommand\NcApart{
  \ib{\irule[\trule{nc-apart}]
    {\AxiomTy = \many{\FamCtrs(\FamPattern) \teq \sigma}}
    {\apart{\FamPattern_j}{\FamPattern_i[\many\tau/\many\alpha_i]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\NcCompt{
  \ib{\irule[\trule{nc-compt}]
    {\compat {\AxiomTy[i]}{\AxiomTy[j]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\CompatInc{
  \ib{\irule[\trule{compt-inc}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\substack{{\Subst = \mgu{\FamPattern_1}{\FamPattern_2}} \\
        {\Subst\sigma_1 = \Subst\sigma_2}}};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}

\newcommand\CompatDist{
  \ib{\irule[\trule{compt-dis}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\Subst = \mgu{\FamPattern_1}{\FamPattern_2}\fails};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}
\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c}
      \NcApart & \CompatDist\\
       \NcCompt & \CompatInc
    \end{array}
  \]  
  \caption{Non Conflicting Equations and Compatibility}
  \label{fig:tf-closed-nc}
\end{figure}

\newcommand\TypeRed{
  \ib{\irule[\trule{ty-red}]
    {\substack{\Axiom\co\AxiomTy\in\GEnv\\\ValidGCtx\GEnv}}
    {\substack{\AxiomTy = \many{\Forall{\many\alpha}\FamCtrs(\FamPattern) \teq \sigma}\\ \forall j < i. ~\nc \AxiomTy i {\many\tau} j}}
    {\substack{\Subst=\mgu {N_i}{\many\tau}\\\tau_0 = \Subst\sigma_i}};
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_0}}} }
}

\subsubsection{Type Reduction}
We can formally specify type reduction, written as $\tystepsto\GEnv\bullet\bullet$, using
the rule $\trule{ty-red}$. This rule says that the $i$-th equation of axiom $\Axiom$,
$\Forall{\many\alpha}{\FamCtrs(\FamPattern_i) \teq \sigma_i}$ is used to reduce
the target type $\FamCtrs(\many\tau)$ to type $\tau_0$. The \noconflict check is the same as
discussed before and we use $\TEvalCtxt\bullet$ to mean that the rewrite can happen anywhere within the type.
$$
\TypeRed
$$

\subsubsection{Consistency and Goodness of Context}\label{subsec:tf-closed-consistency}
Consistency means that we can never derive unsound equalities between ground types,
such as $\Co:\texttt{Int}\teq\texttt{Bool}$, in the system. Ground types ($\GTy$), in our system are
nothing but $\TypeCtrs\many\tau$, $\tau_1\to\tau_2$ and $\Forall\alpha\tau$.
% In short, they are types that do not contain type family constructors.
% Consistency condition is necessary for our system to have progress property. 
We say that a ground context $\GEnv$ is consistent, when for all coercions $\Co$
such that $\CoTyping {\GEnv;\empt} {\Co} {\GTy_1 \teq \GTy_2}$ we have the following:
\begin{enumerate}
\item if $\GTy_1$ is of the form $\TypeCtrs\many\tau$ then so is $\GTy_2$
\item if $\GTy_1$ is of the form $\tau_1\to\tau_2$ then so is $\GTy_2$
\item if $\GTy_1$ is of the form $\Forall\alpha\tau$ then so is $\GTy_2$
\end{enumerate}
In general context consistency is difficult to prove. We take a conservative approach
and enforce syntactic restrictions on the ground context.
\begin{property}[$\Good~\GEnv$]
  A ground context ($\GEnv$) is $\Good$, written $\Good\GEnv$ when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  where $\AxiomTy$ is of the form $\many{\Forall{\many\alpha}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$ and none of the type pattern $\FamPattern_i$ mentions a type family constructor.
  \item The binding variables $\many\alpha$ occur at least once in the type pattern $\FamPattern$,
    on the left hand side of the equation.
  \end{enumerate}
\end{property}
Given our characterization of type reduction in the previous section, we now have to show
that if we have $\Good\GEnv$ then, $\GEnv$ is consistent. One way to prove this is
via confluence of type reduction relation. Whenever we have $\tystepsto \GEnv {\tau_1} {\tau_2}$
then we would know that $\tau_1$ and $\tau_2$ have a common reduct, say $\tau_3$. As type reduction
relation $\trule{ty-red}$ only works on type family's and does not reduce any ground type heads,
confluence would be sufficient prove consistency. However, to prove confluence, it is necessary to assume
termination of type reduction. We get our consistency lemma as follows.
\begin{lemma}[Consistency]
  If $\tystepsto \GEnv \bullet \bullet$ is terminating and $\Good\GEnv$ then $\GEnv$ is consistent.
\end{lemma}

% \subsection{Type safety of \CLTF{}}\label{subsec:tf-closed-safety}
\newcommand\SApp{
  \ib{\irule[\trule{s-app}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Tm_2} {\Tm'_1\App\Tm_2}}}
}
\newcommand\STApp{
  \ib{\irule[\trule{s-tapp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\tau} {\Tm'_1\App\tau}}}
}

\newcommand\SCApp{
  \ib{\irule[\trule{s-capp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Co} {\Tm'_1\App\Co}}}
}

\newcommand\SCast{
  \ib{\irule[\trule{s-cast}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\cast{\Tm_1}\Co} {\cast{\Tm'_1}\Co}}}
}

\newcommand\SBeta{
  \ib{\irule[\trule{s-$\beta$}];
    {\stepsto {(\Lam x \tau \Tm_1)\App\Tm_2} {\Tm_1[x/\Tm_2]}}
  }
}
\newcommand\STBeta{
  \ib{\irule[\trule{s-T$\beta$}];
    {\stepsto {(\TLam \alpha \Tm)\App\tau} {\Tm[\alpha/\tau]}}
  }
}

\newcommand\SPush{
  \ib{\irule[\trule{s-push}]
    {\Co_1 = \sym{\nth 0 \Co}}
    {\Co_2 = \nth 1 \Co};
    {\stepsto {(\cast {\Lam x \tau \Tm} \Co) \App \Tm_1} {\cast {(\Lam x \tau \Tm)\App(\cast{\Tm_1} {\Co_1})} {\Co_2}}}
  }
}
\newcommand\STPush{
  \ib{\irule[\trule{s-tpush}];
    {\stepsto {(\cast {\TLam \alpha \Tm} \Co) \App \tau} {\cast {(\TLam \alpha \Tm)\App\tau} {\Co@\tau}}}
  }
}
\newcommand\STrans{
  \ib{\irule[\trule{s-trans}];
    {\stepsto {\cast {(\cast \Tm \Co)} \MoreCo} {\cast \Tm {\comp\Co\MoreCo}}}
  }
  
}

% As our system has a variety of new terms, we give a new definition
% of the $\stepsto \bullet \bullet$ relation using the rules given in \pref{fig:tf-closed-steps}.
% Similar to the previous \pref{subsec:tcfd-safety}, we should have type safety for \CLTF which
% includes proving preservation and progress.

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c c}
%       \SApp & \STApp & \SCApp & \SCast
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c c}
%       \SBeta & \STBeta & \STrans
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%       \SPush & \STPush
%     \end{array}
%   \]  
%   \caption{Small Step Operational Semantics \CLTF}
%   \label{fig:tf-closed-steps}
% \end{figure}

% For proving preservation lemma, we would have to prove term substitution lemma which, in turn,
% will require that substitutions in coercions are sound. This is given by coercion substitution lemma.
% \begin{lemma}[Coercion Subst]\label{lem:coercion-subst}
%   If $\CoTyping {\GEnv;\VEnv,\alpha,\VEnv'} {\Co} {\Preds}$ and $\ValidType {\GEnv;\VEnv} \tau$
%   then, $\CoTyping {\GEnv;\VEnv,\VEnv'} {\Co[\alpha/\tau]} {\Preds[\alpha/\tau]}$
% \end{lemma}
% The most interesting case would be to prove $\trule{c-axiom}$ case, but the restrictions
% due to \noconflict{} will be enough.

% \begin{lemma}[Preservation \CLTF]
% if $\Typing \empt \Tm \tau$ and $\stepsto \Tm {\Tm'}$ then $\Typing \empt {\Tm'} \tau$
% \end{lemma}

% To have progress property, it is necessary to have consistency which assumes termination of type reduction.
% \begin{lemma}[Progress \CLTF]
%   If $\Typing {\Sigma;\empt} \Tm \tau$ and $\tystepsto \Sigma \bullet \bullet$ is terminating,
%   then either $\Tm \in \Val$, or $\Tm$ is a coerced value of the form $\cast {\Tm'} \Co$ where $\Tm'\in\Val$
%   or there exists a $\Tm_1$ such that $\stepsto \Tm {\Tm_1}$.
% \end{lemma}

\section{Constraint Type families}\label{sec:tf-constrained}
In the previous section for closed type families, we have made an implicit assumption---
the type families are all total, in the sense their domain is all the types.
This is problematic in theory as as well as in practice.
Consider the case where a closed type family does not have an equation for a particular type argument
as shown in \pref{fig:incomplete-tyfam}. We know that !PTyFam Bool!
has no satisfying equations associated with it that gives it a meaning and never will in the future
as it is closed. In our current setup a program that diverges---!loopy!---can be given
this nonsensical type and much worse, the system treats it like a valid type.
\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
type family PTyFam a where
  PTyFam Int = Bool
type family Loop where
  Loop = [Loop]
\end{code}&%
\begin{code}
loopy :: $\forall$ a. a
loopy = loopy
sillyFst x = fst (x, loopy :: PTyFam Bool)
sillyList x = x : x
\end{code}
  \end{tabular}
  \TODO{fix this example}
  \caption{Partial Closed Type Family}
  \label{fig:incomplete-tyfam}
\end{figure}

Next, consider the target type !TEq [a] a!, in \CLTF, this type is not evaluated to
!FF! even though ![a]! and !a! don't have no most general unifier. The reason being there
may be an infinite type such as !Loop! that does unify both ![a]! and !a!. As
!Loop! unwinds infinitely to become ![[[$\ldots$[Loop]$\ldots$]]]! we will have
!TEq [Loop] Loop! evaluate to !TEq [Loop] [Loop]! which is !TT!. This justifies the
reason for not evaluating !TEq [a] a! to !FF!. However, Haskell does not have infinite ground types,
and we thus would expect !TEq [a] a! to reduce to !FF!.
The crux of the problem here is that we treat type families as they are type constructors (ground types).
!Loop! will never reduce to a ground type but we must treat it like one while trying to reduce !TEq [a] a!.
This non-uniform treatment of type family constructors is confusing for programmers.

There also seems to be a mismatch in our intuitive semantics of type families. We think
of them as partial functions on types where each new equation extends its definition. Instead
we should be thinking about them as introducing a family of distinct types and
each new equation equates types that were previously not equal. This distinction in semantics
does matter in practice as illuminated by !sillyList!. If !Loop! is a type then we
can give !sillyList! a type that is !Loop -> Loop!. But this is not its principle type,
as we can generalize it to be  !(a ~ [a]) => a -> a!. Haskell however rejects this program
on the basis of infinitary unification of !a ~ [a]! is not possible. We are left in a position
where we accept some problematic definitions, like !Loop!, but not the others like, (!a ~ [a]!).
To solve this problem we leverage the existing infrastructure that Haskell already has---qualified
types and typeclasses---to make the totality assumption explicit.

% One possible solution to this conundrum is to reject the definition of infinite type families
% like !Loop!. This would however burden the programmers by enforcing a provision of an evidence
% to guarantee termination we thus defer going in that direction.
% Instead,

\subsection{Closed Typeclasses}
Typeclasses can be extended to have new instances. Closed typeclasses, on the contrary,
are classes that will not be able to be extended once they are defined. They essentially
mirrors closed type families in the sense the programmer cannot add more instances after they
are defined. We can define overlapping instances for a closed typeclass and their resolution
will be performed at operator's use site in a top to bottom order on instance declarations.

For example, the type families !TEq a b! and !Plus m n! can be expressed
in the closed typeclass world using !TEqC a b! and !PlusC m n! respectively as shown in \pref{fig:closed-tc-examples}.
\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
class LoopC where
  type Loop
  instance LoopC => LoopC where
    type Loop = [Loop]
\end{code}&%
\begin{code}
class PTyFamC a where
  type PTyFam a
  instance PTyFamC Int where
    type PTyFam Int = Bool
\end{code}\\    
\begin{code}
class {-TOTAL-} TEqC a b where
  type TEq a b
  instance TEqC a a where
    type TEq a a = TT
  instance TEqC a b where
    type TEq a b = FF  
\end{code}&%
\begin{code}
class {-TOTAL-} PlusC m n where
  type Plus m n
  instance PlusC Z m where
    type Plus Z m = Z
  instance PlusC m n => PlusC (S m) n where
    type Plus (S m) n = S (Plus m n)  
\end{code}
  \end{tabular}
  \caption{Closed Typeclasses Examples}
  \label{fig:closed-tc-examples}
\end{figure}
In the constrained type families world, every closed type family will be associated with
a closed typeclass. Any type family without an associated typeclass will be disallowed.
For example, see !class PTyFamC!. The type for !sillyFst! in this system is no longer
!$\forall$ a. a -> a! but instead it is !$\forall$ a. PTyFamC Bool => a -> a!, and the type
checker will flag it as an error wherever it is used; there is no way to satisfy
the instance !PTyFamC Bool!. The type family !Loop! will also need to have
an associated typeclass !LoopC!. To declare an instance of !LoopC!
where !Loop ~ [Loop]! we need to specify !LoopC! to be a constraint on the instance.
This makes the use of !Loop! no longer threatens the type soundness as !LoopC! is unsatisfiable.

Most type families are partial, only some are total and we would want
the users to take advantage of this fact by allowing programmers to specify it.
In general checking for or inferring totality for a given closed type family is a hard problem, thus
we would also give the users a way to let the type checker accept it without checking it.
It would otherwise be inconvenient to express total type families. 

\subsection{Type matching and Apartness Simplified}
The type rewriting in closed type families had a complex criterion for apartness that included
flattening and then checking if they had a unifier using infinitary unification. In constrained type families
we neither have to depend on infinitary type unification nor flattening of types. We can
also relax the restriction that type families cannot appear in the left hand side
of the type rewrite equations due to the class constraints associated with
the use of each type family constructor. The constraint of allowing only terminating
type families can also be lifted as seen from the !LoopC! example, it no longer
threaten type soundness. Apartness in this system is just checking for failure of unification.

\subsection{Formalizing Constrained Type Families}\label{subsec:tf-constrained-formal}
This system is similar to \CLTF except for a few new constructors that
we highlight in \pref{fig:tf-constrained-system}. The ground context keeps track of
two types of type family constructors, a total type family constructor of arity $n$ (written $\FamCtrs\co_\top n$)
and a partial type family constructor of arity $n$ (written $\FamCtrs\co n$).
The variable environment ($\VEnv$) along with variable type bindings
also stores coercion constraint bindings $c\co\Preds$.
Each equation that is introduced by axioms ($\Axiom$) in this system,
are of the form $\Forall {\many\alpha~\many\chi}{\FamCtrs(\many\tau)\teq\sigma}$.
Both $\many\tau$ and $\sigma$ do not have occurrence of any family type constructors. 
The equations are quantified by type variables $\many\alpha$
and also over a new term collection evaluation assumptions $\many\chi$.
These evaluation assumptions are of the form $\alpha|c\co\FamCtrs(\many\tau)\teq\alpha$ and read as
``$\alpha$ such that $c$ witnesses $\FamCtrs(\many\tau)$ reduces to $\alpha$''.
We use these evaluation assumptions to allow type families on the left hand side
of the type equations written in the source program. For example,
the user written type equation  !F (F' a) = G a!, where $G$ and $F'$ are type family constructors,
will be compiled into an equation $\forall a~(b|c:G~a \teq b)(d|c:F'~a \teq d).~ F(d) \teq b$.
% Evaluation assumptions are essential to support axioms that mention
% type families on the right hand side of the equations in source.
We use $\chi$ to remind us that it is more specific than $\Preds$; for any $\chi$,
the left hand side of the type equality is always a type family and right and side is a fresh variable.
The $\tassume\chi\Tm$ is the construct that is used while working with total type families.
It provides a sort of an escape hatch as we are guaranteed to obtain a type family free type
after reducing a total type family.

The ground types in this system can mention type family constructors only in propositions $\Preds$.
For example, the type !$\forall$m n. Add m n => m -> n -> Result m n! would instead be written
as !$\forall$m n. Result m n ~ p => m -> n -> p!. This is an assertion that !Result m n! evaluates to a
type family free type.

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      % &\text{Type family Constructors} &\texttt{\FamCtrs}\\
      % &\text{Type Constructors} &\texttt{\TypeCtrs}\\      
      % \\
      &\text{Type Validity}               &\ValidType \TEnv \tau\\
      &\text{Proposition Validity}        &\ValidProp \TEnv \Preds\\
      &\text{Assumption Validity}      &\ValidAssmp \TEnv {\many\chi}\\
      &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      &\text{Context Validity}            &\ValidCtx\TEnv\\
      \\
      &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      &\text{Resolution Validity}      &\ResTyping \TEnv {\many q} {\many\chi}\\
      \\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau %\bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs
                                              \bnfor \text{\shaded{$\Preds\then\tau$}}&\\
      &\text{Ground Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \TypeCtrs\\
      &\text{Predicates}      &\Preds       &\bnfeq \tau\teq\tau\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \text{\shaded{$\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau)
                                              \teq \sigma$}}}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      % &\text{Coercions}  &\Co,\MoreCo &\bnfeq c \bnfor \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
      %                                   \bnfor \FamCtrs(\many{\Co}) \bnfor \TypeCtrs(\many{\Co})\\
      % &                  &            & \bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
      %                                   \bnfor \text{\shaded{$\Co_1\teq\Co_2\then\MoreCo$}}
                                        \bnfor \text{\shaded{$\qbranch{i}{\many\tau}{\many q}$}} & \\
      &\text{Eval Assumption}   &\chi &\bnfeq \text{\shaded{$(\alpha|c : \FamCtrs\many\tau \teq \alpha)$}} \\
      &\text{Eval Resolution}   &q    &\bnfeq \text{\shaded{$(\tau|\Co)$}}\\      
      \\
      &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
                                        \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau \bnfor\DataCtrs\many{e} \\
      &                  &            & \bnfor \text{\shaded{$\Lam c \Preds \Tm$}} \bnfor \text{\shaded{$\Tm\App \Co$}}
                                        \bnfor \text{\shaded{$\tassume\chi\Tm$}} \\
      &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm \bnfor
                                        \text{\shaded{$\Lam c \Preds \Tm$}}\\
      \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom\co\AxiomTy
                                        \bnfor \text{\shaded{$\GEnv,\FamCtrs\co_\top n$}} \bnfor \GEnv,\FamCtrs\co n
                                        \bnfor \GEnv,\TypeCtrs \co n\\
      &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,\alpha \bnfor \VEnv,x\co\tau
                                        \bnfor \text{\shaded{$\VEnv,c\co\Preds$}}\\
      &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
    \end{array}
  \]
  \caption[Constrained Type Families System]{System for Constraint Type Families}
  \label{fig:tf-constrained-system}
\end{figure}

The new validity judgments reflect the above discussion. The rule \trule{v-qty} ensures
that type equality coercions can appear only in $\Preds$. We do not have the rule \trule{v-tfctr}
in this system to ensure ground types do not mention type family constructors.
The rule \trule{v-qtfp} replaces the rule \trule{v-tfp}. This means that arguments to type family
constructors can mention type families and we no longer have to use special type patterns as in \CLTF's \trule{v-tfp}.
The rule \trule{v-qgax} replaces the \trule{v-gax} that checks axiom equations are valid. This checks that the context
is consistent by making sure it is \Good, as discussed in \pref{subsubsec:tf-constrained-goodness-consistency}.
We also have two new classes of validity judgments, \trule{v-assmn} and \trule{v-assmc} check
that the evaluation assumptions that appear in the axioms are valid, while rules \trule{v-rese}
and \trule{v-resc} ensure that the evaluation resolutions are valid.

\newcommand\ResNil{
  \ib{\irule[\trule{v-rese}]
    {\ValidCtx \TEnv};
    {\ResTyping \TEnv \empt \empt}
  }
}
\newcommand\ResCons{
  \ib{\irule[\trule{v-resc}]
    {\ValidType \TEnv \sigma}
    {\CoTyping \TEnv \Co {\FamCtrs(\many\tau)\teq\sigma}}
    {\ResTyping \TEnv {\many q} {\many\chi[\alpha/\sigma]}};
    {\ResTyping \TEnv {(\sigma|\Co), \many q} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha), \many \chi}}
  }
}

\newcommand\ValidQGndContextAxiom{
  \ib{\irule[\trule{v-qgax}]
    {\substack {\ValidGCtx\GEnv\\
        \fresh \Axiom\GEnv}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i,\TV{\many\chi}} {\tau_{0i}}}}\\
        {\many{\ValidProp{\GEnv;\empt}{\Forall{\many\alpha}{\FamCtrs(\many\tau)\teq\sigma}}}}}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i} {\many\tau_i}}}\\
      {\ValidAssmp {\GEnv;\many\alpha_i} {\many\chi_i}}}}
    {\FamCtrs\co n \in \GEnv};
    {\ValidGCtx{\GEnv,\Axiom\co\many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau_i)\teq\tau_{0i}}}^{i<k}}}
  }
}

\newcommand\ValidNilAssmp{
  \ib{\irule[\trule{v-assmn}];
    {\ValidAssmp \TEnv \empt}}
}

\newcommand\ValidConsAssmp{
  \ib{\irule[\trule{v-assmc}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}^{i<n}}
    {\ValidAssmp {\GEnv;\VEnv,\alpha} {\many\chi}};
    {\ValidAssmp {\GEnv;\VEnv} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha),\many\chi}}}
}
\newcommand\ValidQType{
  \ib{\irule[\trule{v-qty}]
    {\ValidProp \TEnv \Preds}
    {\ValidType \TEnv \tau};
    {\ValidType \TEnv {\Preds\then\tau}}}
}
\newcommand\ValidQTyFam{
  \ib{\irule[\trule{v-qtfp}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\TEnv} {\tau_i}}^{i<n}}
    {\ValidType {\GEnv;\VEnv} \sigma};
    {\ValidProp {\GEnv;\VEnv} {\FamCtrs(\many\tau)\teq\sigma}}}
}


\newcommand\ValidQCoVar{
  \ib{\irule[\trule{v-qcovar}]
    {\ValidVCtx\GEnv\VEnv}
    {\ValidProp {\GEnv;\TEnv} \Preds}
    {\fresh c \VEnv};    
    {\ValidVCtx\GEnv{\VEnv,c\co\Preds}}
  }  
}


% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%       \ValidQType & \ValidQTyFam\\
%       \ResNil & \ResCons\\
%       \ValidNilAssmp & \ValidConsAssmp
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%         \ValidQGndContextAxiom &      \ValidQCoVar 
%     \end{array}
%   \]
%   \caption{Validity Judgments for \QLTF}
%   \label{fig:tc-constrained-validity}
% \end{figure}


\newcommand\QCoAbs{
  \ib{\irule[\trule{t-coabs}]
    {\Typing {\TEnv,c\co\Preds} \Tm \tau};
    {\Typing \TEnv {\Lam c \Preds \Tm} {{\Preds\then\tau}}}}}

\newcommand\QCoApp{
  \ib{\irule[\trule{t-coapp}]
    {\Typing \TEnv \Tm {\Preds \then \tau}}
    {\Typing \TEnv \Co {\Preds}};
    {\Typing \TEnv {\Tm\App\Co} \tau}}}

\newcommand\QAssume{
  \ib{\irule[\trule{t-assum}]
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}}
    {\FamCtrs\co_\top n \in \GEnv}
    {\Typing {\GEnv;\VEnv,\alpha,c\co\FamCtrs\many\tau\teq\alpha} \Tm {\tau}};
    {\Typing {\GEnv,\VEnv} {\tassume{(\alpha|c\co\FamCtrs\many\tau\teq\alpha)}\Tm} \tau}}}


\newcommand\QCoAxiom{
  \ib{\irule[\trule{co-qaxiom}]
    {\substack {{\Axiom\co\AxiomTy \in \GEnv}\\
        {\AxiomTy = \many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau) \teq \sigma}}}}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\substack {\ValidCtx {\GEnv;\VEnv}\\
        \ResTyping {\GEnv;\VEnv} {\many{q}} {\many\chi[\alpha_i/\tau_i]} }};
    {\CoTyping {\GEnv;\VEnv} {\qbranch i {\many\tau} {\many q}} {\FamCtrs (\many\sigma\many{[\alpha_i/\tau_i]}) \teq \sigma_0\many{[\alpha_i/\tau_i]}}}}
}

\newcommand\QCoQual{
  \ib{\irule[\trule{co-qual}]
    {\many{\Typing \TEnv {\Co_i} {\tau_i\teq\sigma_i}}^{i<3}};
    {\CoTyping \TEnv {\Co_1\teq\Co_2 \then\Co_3} {(\tau_1\teq\tau_2\then\tau_2)\teq(\sigma_1\teq\sigma_2\then\sigma_3)}}}}

\newcommand\QCoVar{
  \ib{\irule[\trule{co-var}]
    {c\co\Preds \in \VEnv};
    {\Typing {\GEnv;\VEnv} {c} \Preds}}
}

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}[ht]{c c}
%       \QCoVar & \QCoAxiom\\
%       \QCoAbs & \QCoQual \\
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c c}
%       \QCoApp & \QAssume
%     \end{array}
%   \]
%   \caption[Selected Typing Judgments for \QLTF]{Selected Typing Judgments \QLTF{}}
%   \label{fig:tf-constrained-typing}
% \end{figure}

The typing judgments new to this system are shown in \pref{fig:tf-constrained-typing}.
The rule \trule{t-coabs} abstracts over coercion variable while \trule{t-coapp} applies a coercion
argument to a term. We have a new version of axiom application rule \trule{co-qaxiom}.
It is very similar to \trule{co-axiom}, except that we need
to provide extra validity resolutions $\many q$ that instantiate the validity assumptions $\many\chi$.
The validity resolutions are of the form $(\tau|\Co)$ where the type $\alpha$
in validity assumptions $(\alpha|c\co\FamCtrs(\many\tau)\teq\sigma)$ is instantiated to $\tau$ and
$\Co$ proves the equality and instantiates $c$. This is exactly what the rule \trule{v-resc} does.
% We write $[\chi/q]$ for a substitution where the assumption $\chi$ is substituted by $q$.
Finally, The rule \trule{t-assum} is the special rule that says we are allowed to assume arbitrary applications
of a type family would give us a type free type. We can indeed do this by the definition of total type family.

\subsubsection{Type reduction}
The type reduction relation is given using two rules \trule{qty-red-top} and \trule{qty-red}.
The rule \trule{qty-red-top} does the heavy lifting of producing the correct substitutions
for types ($\Subst_1$) as well as evaluation resolutions ($\Subst_2$). The correct
equation selection is done by $\noconflict$ criterion.
The specialty of this relation is that we ensure applying type arguments to type families only when
they satisfy proper constraints with the use of evaluation resolutions,
thus guaranteeing every type reduction to eventually obtain a type family free type.
And due to the fact that type family free types do not reduce, we can prove termination,
for the type reduction relation.
\newcommand\QTyRed{
  \ib{\irule[\trule{qty-red}]
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1} };
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_1}}} }
}
\newcommand{\QTyTopRed}{
  \ib{\irule[\trule{qty-red-top}]
    {\substack{ {\Axiom\co\AxiomTy\in\GEnv}\\
        {\ValidGCtx\GEnv}\\
        {\AxiomTy_i = \Forall{\many\alpha_i~\many\chi_i}\FamCtrs(\many{\sigma_i}) \teq \sigma_0}\\
        {\forall j < i. ~\nc \AxiomTy i {\many\tau} j}
      }}
    {\substack {{\many\chi_i = \many{(\alpha'|c\co\MoreFamCtrs(\many\tau')\teq\alpha')}}\\
        {\tystepsto \GEnv {\many{\MoreFamCtrs(\Subst_1\many\tau')}} \many{\tau_0}}}}
    {\substack {{\Subst_1 = \mgu{\many\sigma_i}{\many\tau}}\\
        {\Subst_2 = [\many{\chi_i}/\many{\MoreFamCtrs(\Subst_1\many\tau')\teq\tau_0}]}\\
        {\tau_1 = \Subst_1\Subst_2\sigma_0}\\
      }};
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1}} }
}  

\begin{figure}[ht]
    \footnotesize
  \[
  \begin{array}[ht]{c c}
    \QTyRed & \QTyTopRed
  \end{array}
  \]
  \caption{Type reduction}
  \label{fig:tc-constrained-tyred}
\end{figure}


\subsubsection{Goodness and Consistency}\label{subsubsec:tf-constrained-goodness-consistency}
The definition of Goodness can now be relaxed due to simplifying apartness criteria for types.
\begin{property}[$\Good~\GEnv$ relaxed]
  A ground context ($\GEnv$) is $\Good$, written $\Good\GEnv$ when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  where $\AxiomTy$ is of the form $\many{\Forall{\many\alpha~\many\chi}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$.
  \item The binding variables $\many\alpha$ occur at least once in the type arguments $\many\tau$,
    on the left hand side of the equation.
  \end{enumerate}
\end{property}
With the reduction relation defined in previous section, and knowing that it is always terminating,
we can use Newman's lemma\cite{newman_theories_1942} to prove that type reduction is confluent.
Thus we get our relaxed consistency lemma as follows:
\begin{lemma}[Consistency] If $\Good\GEnv$ then $\GEnv$ is consistent \end{lemma}

% \subsection{Type safety of \QLTF}\label{subsec:tf-constrained-safety} 
% \newcommand\TQPush{
%   \ib{\irule[\trule{t-qpush}]
%     {\substack {{v = \Lam c \Preds \Tm}\\
%         {\MoreCo_0 = \nth 0 \MoreCo}}}
%     {\substack {{\MoreCo_1 = \sym{\nth 1 \MoreCo}}\\
%         {\MoreCo_2 = \nth 2 \MoreCo}}};
%     {\stepsto {(\cast v \MoreCo)\App \Co} {\cast {v\App(\comp{\comp{\MoreCo_0}{\Co}}{\MoreCo_1})} \MoreCo_2}}
%   }
%   }

% \newcommand\TQResolve{
%   \ib{\irule[\trule{t-qres}]
%     {\chi = (\alpha|c\co\FamCtrs(\many\tau)\teq\alpha)}
%     {\FamCtrs(\many\tau) \Downarrow q};
%     {\stepsto {\tassume\chi\Tm} {e[\chi/q]}}}
% }

% \newcommand\TQBeta{
%   \ib{\irule[\trule{t-c$\beta$}];
%     {\stepsto {(\Lam c \Preds \Tm)\App\Co } {\Tm[c/\Co]}}}
% }
% Selected rules for term evaluation are shown in \pref{fig:tf-constrained-opsem}.
% The rule \trule{t-qres} evaluates a constraint function application similar to function application
% while the rule \trule{t-qpush} splits the inner coercion $\MoreCo$ so that it can be commuted with
% the coercion application $\Co$. The rule \trule{t-qres} is the rule that illuminates the evaluation
% for total type family constructors. The clause $\FamCtrs(\many\tau) \Downarrow q$ says that we
% find a witness for $\FamCtrs(\tau)$ reduction to a ground type to build an appropriate evaluation resolution
% and apply it to the enclosing term.
% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%       \TQResolve & \TQBeta & \TQPush
%     \end{array}
%   \]
%   \caption{Small Step Operational Semantics \QLTF}
%   \label{fig:tf-constrained-opsem}
% \end{figure}
% We can thus state the preservation and progress for this system as follows:
% \begin{lemma}[Preservation \QLTF]
%   If $\Typing \empt \Tm \tau$ and $\stepsto \Tm {\Tm'}$ then $\Typing \empt {\Tm'} \tau$
% \end{lemma}
% \begin{lemma}[Progress \QLTF]
%   If $\Typing {\Sigma;\empt} \Tm \tau$
%   then either $\Tm$ is a value, or $\Tm$ is a coerced value of the form $\cast {\Tm'} \Co$ where $\Tm'\in\Val$
%   or there exists a $\Tm_1$ such that $\stepsto \Tm {\Tm_1}$.
% \end{lemma}


% \section{Related Work}\label{sec:related-work}
% Functional dependencies have also been formalized using constraint handling rules (CHR),
% a technique from logic programming\cite{sulzmann_understanding_2007}. There is no known
% implementation of functional dependencies using CHR.

% There are several variations of type families that have been explored and implemented in GHC.
% Open type families\cite{schrijvers_type_2008}, which predates closed type families,
% are extendable in a sense that the programmer can add more equations.
% To maintain both, extensibility and compatibility, open type families disallow overlapping equations.
% A system with both closed type families and open type families can co-exist without hiccups. This is
% indeed the current implimentaion of GHC. The semantics of the instance equations is similar to
% that of unordered collection of type equations, unlike
% closed type families, where the equations are considered in a top to bottom fashion.
% Associated types\cite{chakravarty_associated_2005} are a syntactic variation of open type families.
% Each typeclass has an associated type parameterized over typeclass parameters. Each instance of such typeclass
% specifies what the associated type's interpretation in the context. Injective type families\cite{stolarek_injective_2015}
% uses the idea from functional dependencies to specify additional injective constraints that the type family instance
% should satisfy to aid type inference.

\section{Conclusion and Future Work}\label{sec:conclusion}
% All three systems described in the paper have a common property that they are based on
% the principle of type erasure. The type analysis is performed at compile time and
% the types are erased from the programs at runtime.
% This ensures that there is no runtime overheads because of types.
% Due to type safety properties of each of these systems, we are guaranteed
% that if a program passes the type check then it does not crash at runtime.
% A feature that we have not included in each of the systems is the system of kinds, or type of types.
% They provide a way to have partially applied data constructors. The reason to not include them is that
% they are orthogonal to our discussion. Adding them to the system will not change type safety of the language.

% With squinting eyes, typeclasses with functional dependencies and type families are trying to achieving the
% same goal---computation on types. While functional dependencies have a flavor of relations,
% type families have a flavor of equations. Haskell programmers using GHC,
% prefer functional programming over logic programming making type families their preferred choice.
% Further, a buggy implementation of functional dependencies in GHC, does not help its case either.
% A formal proof about the equality of the expressive power of functional dependencies and
% type families is an open problem\cite{TODO}. 

Type computation, either using functional dependencies or type families
is an attractive feature for programmers as it considerably improves language expressivity.
If functional dependencies are morally equivalent to type families
one would expect to have either of the two cases to be true
1) translation mechanism that can go from one style to another or 2)
translation of both the language features into a common intermediate language.
As of now both of these remain an active area or research\cite{karachalias_elaboration_2017,sulzmann_understanding_2007}.

The type safety formalization of closed type families hinges on the assumption that
type family reduction are terminating. This problem is effectively solved by using constrained type families.
In conclusion, the motivation of constraint type families is to reunite
the idea of functional dependencies and type families that had previously diverged.
The use of equality constraints to ensure that type family applications are well defined
is reminiscent of the use of functional dependencies to ensure typeclass instances are well defined.
\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{typeclasses}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
