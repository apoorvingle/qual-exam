%% FIXME:
%% 1. Space hacking for definitions and list items
%% 2. Tables and array looks
%% 3. Shaded box with \shaded

\newif\ifcomments\commentstrue

\RequirePackage[svgnames,dvipsnames,prologue]{xcolor}

\documentclass[format=acmsmall,manuscript,review,screen,nonacm,margin=1in,11pt]{acmart}

\usepackage{typeclasses}

\title{Dialects of Type Computations in Haskell}
% \subtitle{Typeclasses, functional and Type Families}
\author{Apoorv Ingle}
%\orcid{0000-0002-7399-9762}
\affiliation{%
  \institution{University of Iowa}
  \department{Department of Computer Science}
  \streetaddress{McLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
% \keywords{typeclass, type family}

\begin{document}
\begin{abstract}
  Static types have two advantages: (1) they serve as a guiding tool
  to help programmers write correct code, and (2) the typechecker
  can help identify code that does not behave correctly.
  An expressive type system can guarantee stronger claims about programs.
  Type level computations make the type system more expressive.
  In Haskell, there are two styles of type level computation---functional dependencies
  and type families. In this report we describe these two language features with examples,
  formalize and compare them.
\end{abstract}
\maketitle
%\pagestyle{plain}
\vspace{-1.25em}
\section{Introduction}
Parametric polymorphism is a powerful technique that allows programs to work on
a wide variety of types. The identity function, !id!, that takes an input and returns it
without modification has the type !$\forall$$\alpha$. $\alpha$ -> $\alpha$!,
We read this type as follows: for all types, !$\alpha$!, if the argument is of type !$\alpha$!
then the function returns a value of type !$\alpha$!.
We also need to tame unconstrained polymorphism.
A division function on all types does not make sense. We cannot
divide a function that multiplies two numbers by a function that adds two numbers.
The type !$\forall$ $\alpha$. ($\alpha$ $\times$ $\alpha$) -> $\alpha$!, that accepts
a pair of values of type !$\alpha$!, and returns the first component divided by the
second component is too general to describe division. A constrained polymorphic type,
!$\forall$ $\alpha$. (Dividable $\alpha$) => ($\alpha$ $\times$ $\alpha$) -> $\alpha$!,
more accurately describes the functions intention. Intuitively, the predicate,
!Dividable $\alpha$!, means: only those types that satisfy this predicate
have a meaningful divide function. Typeclasses\cite{wadler_polymorphism_1989} give a mechanism
of having such constrained polymorphic types. Theory of qualified types\cite{jones_qualified_1994}
formalizes typeclasses and justifies constrained polymorphism
without compromising type safety by having predicates as a part of type syntax.

A typeclass also defines relations on types. This gives programmers a way to
encode computations at type level. However, using relations to encode type computations
is cumbersome. A new language feature, type families\cite{schrijvers_towards_2007}, was introduced in Haskell
to enable type functions. They are stylistically more obvious for functional programmers.
Naturally, type families warrants a richer system of types and ensuring type safety
for such a language is nontrivial.

\TODO{rework this at the end}
The scope of the current article is as follows:
we first give examples and intuitive set semantics for typeclasses in the beginning of \pref{sec:tc},
and then describe functional dependencies\cite{jones_tcfd_2000} with some examples in \pref{sec:fd}.
We formalize them in \pref{subsec:tc-formal} and describe their consequences % of introducing
% functional dependencies by improving type inference and detecting ambiguous types
in \pref{subsec:fd-improve}.
We also give a brief description of type safety for this system in \pref{subsec:tcfd-safety}.
We then describe two flavors of type families---closed type families\cite{eisenberg_typefamilies_2014}
in \pref{sec:tf-closed} and  constrained type families\cite{morris_typefamilies_2017}
in \pref{sec:tf-constrained} with examples and their respective formalization in \pref{subsec:tf-closed-formal}
and \pref{subsec:tf-constrained-formal}. We then give some details about the type safety of
each system in \pref{subsec:tf-closed-safety} and \pref{subsec:tf-constrained-safety} respectively.
To conclude we % give some related work in \pref{sec:related-work}, and 
draw some comparisons between the three systems while pointing towards some open questions in \pref{sec:conclusion}.
To be concrete about the examples we will use a Haskell like syntax.

\section{Typeclasses}\label{sec:tc}
Typeclasses can be thought of as collection of types. Each typeclass is accompanied by its member
functions that all the instances ought to support. For example,
equality can be expressed as a typeclass !Eq a! as follows:
\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{c c c}
\begin{code}
class Eq a where
  (==) :: a -> a -> Bool
\end{code}&%
\begin{code}
instance Eq Int where
  a == b = primEQInt a b
\end{code}&%
\begin{code}
instance Eq Char where
  a == b = primEQChar a b
\end{code}
  \end{tabular}
\end{figure}

The instances of !Eq! typeclass can be types such as integers (!Int!) and characters (!Char!) but
defining equality on function types (!a->b!) is not be meaningful. The operator
!(==)! is not truly polymorphic: it cannot operate on function types. Rather
it is constrained to only those types that have an !Eq! instance defined.
We make this explicit in the type of the operator !(==)!, by saying it's defined
only on those types !a! that satisfy the !Eq a! predicate,
or !(==) :: $\forall$a. Eq a => a -> a -> Bool!. We read this type as: For any type !a! that
satisfies the predicate !Eq a!, if we are given two
values of type !a!, then we can return a Boolen value indicating if the two arguments are equal.

%% What are these?
There is nothing special about typeclasses having just one type parameter. 
A multiparameter typeclass with $n$ type parameters represents a relation on $n$ types.
An example of such a typeclass, !Add a b c! is shown in \pref{fig:multip-typeclass}.
It represents a relation of types !a!, !b! and !c! such that adding values of type !a! and type !b!
gives us a value of type !c!. The type of the operator, !(+)!, that performs this add operation will be
!$\forall$a b c. Add a b c => a -> b -> c!. Instances of such a typeclass would be !Add Int Int Int!,
!Add Int Float Float!, and so on.
\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{c c c}
\begin{code}
class Add m n p where
  (+) :: m -> n -> p
\end{code}&%
\begin{code}
instance Add Int Float Float where
  (+) a b = addFloat (toFloat a) b
\end{code}&%
\begin{code}
instance Add Int Int Int
  (+) a b = intAdd a b
\end{code}
  \end{tabular}
  \begin{tabular}{l l}
\begin{code}
instance Add Int Float Int where
  (+) a b = addInt a (toInt b)
\end{code}&%
\begin{code}
e :: (Add Int Float b, Add b Int c) => c
e = (1 + 2.0) + 3
\end{code}
  \end{tabular}
  \caption{Multiparameter Typeclasses}
  \label{fig:multip-typeclass}
\end{figure}

%% What problems do they introduce?
Multiparameter typeclasses, however, are difficult to use in practice.
Suppose the programmer defines two instances: !Add Int Float Float! and !Add Int Float Int!
and writes an term !e = (1 + 2.0) + 3!.
Due to the use of the operator !(+)! in !e!, the most general type of !e! synthesized
by the type inference algorithm will be !$\forall$ b c. (Add Int Float b, Add b Int c) => c!.
Notice how the type variable !b! occurs only in the predicate set !(Add Int Float b, Add b Int c)!.
Such types are called ambiguous types and the type variables, such as !b!,
are called ambiguous type variables. Ambiguous types do not have well defined semantics in Haskell
due to incoherence. The compiler cannot choose an interpretation of the subterm !(1 + 2.0)!, it can
either be an !Int! or a !Float!. Haskell, thus, disallows ambiguous types by reporting a type error.
However, as a consequence, the type errors can cause confusion; although the issue is with
instances of typeclass !Add m n p!, the type error is raised at the term that may be
defined in a separate location.


\section{Functional Dependencies with Examples}\label{sec:fd}
%% How does this solve the previous problem
Typeclasses with functional dependencies\cite{jones_tcfd_2000} is a generalization of multiparameter typeclasses.
It introduces a new syntax where the user can specify a dependency between the type parameters
in the typeclass declaration. There is no change in the syntax of declaring instances.
!Add m n p! typeclass, as shown in \pref{fig:add-tc-fd}, now has a functional dependency
between the type parameters such that types !m! and !n! determine the type !p!.
In general we can have multiple parameters on both sides of the arrow,
(!$x_1$, ..., $x_m$ -> $y_1$, ..., $y_m$!). We write !X -> Y! to mean
``the parameters \texttt{X} uniquely determine the parameters \texttt{Y}''.

\begin{figure}[h t]
  \footnotesize
  \begin{tabular}{l l}
\begin{code}
class Add m n p | m n -> p where
  (+) :: m -> n -> p
\end{code}&%
\begin{code}
instance Add Int Float Float where
  $\ldots$
\end{code}\\
          &
\begin{code}
instance Add Int Float Int where -- Error!
  $\ldots$
\end{code}
  \end{tabular}
  \caption{\texttt{Add m n p} with Functional Dependency and Conflicting Instances}
  \label{fig:add-tc-fd}
\end{figure}

The programmer can use functional dependencies to specify the intention of the typeclasses
more accurately. It gives the compiler a way to detect inconsistent instances and report an error
whenever it detects one. For example, the functional dependency on !m n -> p!
can now help the typechecker flag the instance !Add Int Float Int! to be in conflict with the instance
!Add Int Float Float!.

Further, due to functional dependencies,
we may also be able to determine the ambiguous type variables in a type.
Let's reconsider the ambigouous type of term !e! from the previous section, we can now determine
that !b! has to be !Float!. It is determined by the types !Int! and !Float! of the class instance.
Thus, !e :: (Add Int Float Float, Add Float Int c) => c!.
We can even go a step further and improve this seemingly polymorphic type.
The type variable !c! can be determined to be !Float!, giving us the final type synthesis !e :: Float!.
It would be impossible to make such an improvement without the functional dependency.

\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{l l}
\begin{code}
data Z   -- Type level Zero
data S n -- Type level Successor
\end{code}&%
\begin{code}
class IsPeano c
instance IsPeano Z
instance IsPeano n => IsPeano (S n)
\end{code}\\
\begin{code}
class Plus m n p | m n -> p
instance IsPeano m => Plus Z m m
instance Plus n m p => Plus (S n) m (S p)
\end{code}&%
\begin{code}
data Vector s e = Vec (List e)
concat_vec :: Plus m n p
     => Vector m e -> Vector n e -> Vector p e
concat_vec (Vec l1) (Vec l2) = Vec (append l1 l2)
\end{code}
  \end{tabular}
  \caption{Peano Arithmetic and Vector Operations with Functional Dependencies}
  \label{fig:peano-arith}
\end{figure}

With functional dependencies at our disposal, we can even perform Peano arithmetic at type level,
as shown in \pref{fig:peano-arith}. The two datatypes !Z! and !S n!
represent the number zero and successor of a number !n!, respectively.
The instances of !IsPeano! assert that: !Z! is a peano number, and if !n! is a peano number
then !S n! is a Peano number. The instances of !Plus! typeclass relates three peano numbers such that the relation
holds if the first two peano numbers add up to be equal to the third. Thus, !Peano Z m m! asserts the relation
!0 + m = m!, and !Plus n m p => Plus (S n) m (S p)! asserts that if n + m = p then (1 + n) + m = (1 + p).
The !concat_vec! function demonstrates why type level computation would be useful
for a linear algebra library. The type of !concat_vec! says that the size of the resulting
vector is the sum of the sizes of the argument vectors.

\subsection{Formalizing Typeclasses with Functional Dependencies}\label{subsec:tc-formal}
%% Fix the language
To formalize the system, we first need to fix the language.
The surface syntax, the one that the user writes, in shown in \pref{fig:ty-fd-formal}.
We will call this \TCFD{}.
% syntax for types
The syntax of types ($\tau$) consists of  type variables ($\alpha$),
functions ($\tau\to\sigma$), and type constructors $\TypeCtrs\many{\alpha}$.
The qualified types ($\rho$) are given as $\ClassCtrs\many\alpha\then\tau$
where $\ClassCtrs\many\alpha$ constrains the type $\tau$. Type schemes ($\sigma$) are quantified constraint types.
%% The term language
The terms or expressions in the language ($e$) consists of countably
infinite set of variables ($x, y$), functions ($\Lam x \tau e$),
function applications ($e_1\App e_2$), overloading of operators is achieved by ($\Let x {e_1} {e_2}$), and
data constructors ($\DataCtrs$) define values for a user defined type.
% Typeclasses and datatypes
% We have syntax that enables the programmer to declare their own types using the keyword !datatype!
% followed by a list of data constructors, declare typeclasses with a keyword !class! with a list
% of functional dependencies, and a list of typeclass methods and their type signature
% following the keyword !where!. Instances of typeclasses are declared using
% the keyword !instance! and definitions of each of the class method following the !where! keyword.
% Both the typeclass declarations and instance declarations can optionally have a list of
% additional prerequisite constraints on the right hand side of !=>!.
% Although we are using the same symbol !(->)! to denote functional dependency and function types,
% the context of its appearance will differentiate its meaning. Same is the case for !=>! where it is used
% A typical program in this language is a collection of datatype declarations,
% class declarations with their instances and terms. 
Values in this system are data constructors and lambda expressions.

\begin{figure}[ht]
    \footnotesize
  \[
  \begin{array}{l l l}
    &\text{Type Variables}     &\alpha, \beta\\
    &\text{Term Variables}     &x, y\\
    &\text{Class Constructors} &\ClassCtrs\\
    % &\text{Data Constructors}  &\DataCtrs\\
    % &\text{Type Constructors}  &\TypeCtrs\\
    \\
    &\text{Term Typing}        &\QTyping \Preds \TEnv \Tm \tau\\
    % &\text{Term Eval}          &\stepsto \Tm {\Tm'}
  \end{array}
  \begin{array}{l l l l}
    &\text{Predicates}      &\pi &\bnfeq C\many{\tau}\\
    &\text{Predicate Set}   &\Preds &\bnfeq \many\pi\\
    &\text{Types}           &\tau   &\bnfeq \alpha \bnfor \tau\to\tau\\% \bnfor \TypeCtrs\many{\alpha}\\
    &\text{Qualified Types} &\rho   &\bnfeq \tau \bnfor \Preds\then\tau\\
    &\text{Type Schemes}    &\sigma &\bnfeq \forall{\many\alpha}.\rho\\
    &\text{Terms}           &\Tm    &\bnfeq x \bnfor \Tm\App \Tm \bnfor \Lam x\tau \Tm \bnfor \Let x {\Tm} {\Tm}\\
    \\
                                      %\bnfor \DataCtrs\many{\Tm}
                                      % \bnfor \texttt{\textbf{case }} e \texttt{\textbf{ of }} \many\Ptrns\\
    % &\text{Values}          &\Val   &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm\\
    &\text{Typing Environment} &\TEnv &\bnfeq \empt \bnfor \TEnv,x\co\sigma
    % \\
    % &\text{Data Declarations}     &    &T \many{\alpha} = \many{\DataCtrs \many{\alpha}}\\
    % &\text{Class Declarations}    &    &\texttt{\textbf{class}}\ \Preds \then \ClassCtrs\many{\alpha}
    %                                      \mid \many{\many{\alpha} \to \many{\alpha}}
    %                                          \texttt{\textbf{ where }}\many{x :: \sigma}\\
    % &\text{Instance Declarations} &    &\texttt{\textbf{instance}}\ \Preds \then \ClassCtrs\many{\tau}~
    %                                      \texttt{\textbf{ where }}~ \many{x = e}
  \end{array}
  \]
  \caption[\TCFD Excerpt]{Excerpt of \TCFD}
  \label{fig:ty-fd-formal}
\end{figure}

\subsubsection {Notations}\label{subsubsec:fd-notations}
We will use some notations as follows. We use subscripts on objects
($\alpha_1,\ldots, \alpha_n$) to distingush them.
$\many{\alpha}$ means a collection of $\alpha_1, \alpha_2, ..., \alpha_n$ items of arbitrary length.
We use $S_1 \setdiff S_2$ to denote the set difference operation. For an object $X$,
$\TV{X}$ is the set of variables that are free in $X$.
We write $M[\many{x}/\many{y}]$ to denote the substitution where each variable
$x_i$ is mapped to $y_i$ in $M$. Alternatively we also
write $\Subst X$ for an substitution $\Subst$ applied to object $X$.
We denote the most general unifier for two types $\tau_1$ and $\tau_2$ (if it exists),
by $\mgu{\tau_1}{\tau_2}$\cite{robinson_machine-oriented_1965}. For the sake of convenience,
we would also write $\mgu{\many{\tau_1}}{\many{\tau_2}}$ to give us a composition of most general
unifier for each pairs of types $(\tau_{1i}, \tau_{2i})$.
% We abbreviate the $\ClassCtrs\many\alpha$ as $\Preds$ and $\MorePreds$
For a typeclass declaration we write !class P => C $\many t$!, where !$\many t$! are the type parameters
of the class and \Preds{} are the constraints that must be satisfied.
We denote the set of functional dependencies of class !C! with $\fundep{C}$.
We write !$X$ -> $Y$! for an arbitrary functional dependency.
The determinant of a functional dependency is denoted by $t_{X}$
and the dependent is denoted by  $t_{Y}$. $\TV{C}$ denotes the set of type parameters
of the class !C!. A predicate set $\Preds$ is satisfiable if there exists a substitution,
$\Subst$, such that $\emptyset\entails \Subst\Preds$.
We write $\satisfyable\Preds = \Set{\Subst \mid \emptyset \entails \Subst P}$
to mean the set of all substitutions that satisfy $\Preds$.

For example, for a typeclass declaration !class Add m n p | m n -> p!,
we have, $t = (a, b, c)$, $\fundep{Add}=$!$\{$ m n -> p $\}$!, $\TV{C} = \Set{m, n, p}$.
For the functional dependency !m n -> p!, we have, $t_X = {(\texttt{m},\texttt{n})}$ and $t_Y = {(\texttt{p})}$.
Given a set of functional dependencies $\texttt{J}$, we define the closure operation,
\TODO{fix this definition? It seems broken}
$\closure Z {\texttt{J}}$, on $Z \subseteq t$, to be equal to all the type parameters
that are determined by set of the functional dependencies \texttt{J}.
Thus, $\closure {\Set{p}} {\fundep{Add}} = \Set{p}$,
$\closure {\Set{m}} {\fundep{Add}} = \Set{m}$ while $\closure {\Set{m, n}} {\fundep{Add}} = \Set{m, n, p}$.

%% Introduction to type system
% \cite{jones_qualified_1994} uses a general framework called a theory
% of qualified types to formalize the type system for \TCFD{}.
% In this framework, the predicates on types are part of the syntax of the type language.
% The predicates on types in our language are nothing but typeclasses.
% Declaring instances is the assertion that the types satisfy the predicate.
We say that the tuple $\QTyping \Preds \TEnv \Tm \tau$ to be a judgment
that holds when there is a typing derivation that shows $\Tm$ has type $\tau$
with predicates $\Preds$ being satisfied and the free variables in $\Tm$
are given types by the typing environment $\TEnv$, that maps term variables to its types.
% \AI{Should this be a declarative type system or a syntax directed type inference algorithm?}
% This should be a declarative type system. Algorithmic stuff can be asserted to be true.
The typing judgments for the language are shown in \pref{fig:tcfd-typing}.
The generalize function $\Gen \TEnv \tau$ quantifies
all the free variables of the type $\tau$ that do not occur in the domain
of the type environment $\TEnv$, i.e., $\Gen \TEnv \tau = \forall(\TV\tau\setdiff\dom\TEnv).\tau$.
The instantiate function $\Ins\sigma$ maps each quantified variable in $\sigma$ to a
fresh variable, i.e. if $\sigma=\forall\many{\alpha}.\Preds\then\tau$,
then $\Ins\sigma = \Preds[\many{\alpha}/\many{\beta}]\then\tau[\many{\alpha}/\many{\beta}]$
where $\many\beta$ are fresh. The variables need to be fresh to avoid
any conflict with the existing type variables. The typing rule
for function abstraction $\trule{\I\to}$ says that if we can show a typing derivation
where the body of the function $\Tm$ has the type $\tau$ with the typing environment
extended with the variable that represents the argument for the function with type $\tau_1$,
then we have a judgment that shows the lambda term
has type $\tau_1\to\tau_2$.

\newcommand\TAbs{
  \ib{\irule[\trule{t-abs}]
    {\QTyping \Preds {\TEnv, x\co\tau_1} {\Tm} {\tau}};
    {\QTyping \Preds \TEnv {\Lam x {\tau_1} \Tm} {\tau_1 \to \tau}}}
}
 
\newcommand\TApp{
  \ib{\irule[\trule{t-app}]
    {\QTyping \Preds \TEnv {\Tm_1} {\tau_2 \to \tau}}
    {\QTyping \Preds \TEnv {\Tm_2} {\tau_2}};
    {\QTyping \Preds \TEnv {\Tm_1\App\Tm_2} {\tau}}}
}

\newcommand\TLet{\ib{\irule[\trule{t-let}]
  {\QTyping \Preds {\TEnv} {\Tm_1} \tau_1}
  {\sigma = \Gen \TEnv {\Preds\then\tau_1}}
  {\QTyping {\Preds_1} {\TEnv, x\co\sigma} {\Tm_2} \tau_2};
  {\QTyping {\Preds_1} \TEnv {\Let x {\Tm_1} {\Tm_2}} \tau_2}}
}

\newcommand\TVar{
  \ib{\irule[\trule{t-var}]
    {x\co\sigma \in \TEnv}
    {P\then\tau = \Ins{\sigma}};
    {\QTyping \Preds \TEnv x \tau}}
}

\newcommand\TDataIntro{
  \ib{\irule[\trule{\I D}]
    {\many{\QTyping \Preds \TEnv {\Tm_i} {\tau_i}}}
    {D\co{\many{\tau_i}} \to T\many\tau \in \TEnv};
    {\QTyping \Preds \TEnv {D\App\many{\Tm_i}} {T\many{\tau}}}}}

\newcommand\TDataElem{
  \ib{\irule[\trule{\E D}]
    {\QTyping \Preds \TEnv e {\TypeCtrs\many{\tau'}}}
    {\many{\QTyping \Preds \TEnv {M_i} \tau}};
    {\QTyping \Preds \TEnv {\Case e {\many M}} {\tau}}}
}

\newcommand\TMatch{
  \ib{\irule[\trule{t-match}]
    {\QTyping \Preds \TEnv {D\many{x_i}} {\TypeCtrs\many{\tau_i}}}
    {\QTyping \Preds {\TEnv,\many{x\co\tau_i}} \Tm \tau};
    {\QTyping \Preds \TEnv {D\App\many{x_i} \to \Tm} {\tau}}}
}


\begin{figure}[ht]
  \footnotesize
  \[
    \begin{array}{c c}
      \TAbs & \TApp\\
      \TVar & \TLet\\
      %& \TDataElem
    \end{array}
  \]
  % \[
  %   \begin{array}{c}
  %     \TDataIntro
  %   \end{array}
  % \]
  \caption{Typing judgments for \TCFD{} Terms}
  \label{fig:tcfd-typing}
\end{figure}

The typing judgment for function application rule $\trule{\E\to}$
says that if we can show that the left hand term $\Tm_1$ has type $\tau_2 \to\tau$ and additionally we can
show that the right hand term $\Tm_2$ has type $\tau_2$ then we can show
that the term $\Tm_1\App\Tm_2$ has type $\tau$. The rule $\trule{tlet}$ says that we can show
that the type of $\Tm_2$ with a variable $x$ bound to a term $\Tm_1$ is of type $\tau_2$
only if we can build a derivation that shows $\Tm_1$ as $\tau_1$ and we can show that
$\Tm_2$ has type $\tau_2$ with typing environment extended with the variable $x$ mapped
to the generic instance of $\tau_1$. The $\trule {tlet}$ is in essence overloading in action
as the variable $x$ is assigned a generic type. The rule $\trule{tvar}$ says that to show
that the type of the variable $x$ is $\tau$ we need to look it up in our typing environment
and instantiate it with fresh variables. % The rule $\trule{}$ says that if need to show
% that the datatype constructor $\DataCtrs\many{\Tm_i}$ has a user defined type $T\many\tau$
% then we need to show that each of the arguments are well typed
% and the data constructor has the right type as given by its declaration.
% The data constructor case can be viewed as a generalized version of function types as $\tau_1\to\tau_2$ is
% a type constructor and $\Lam x \tau \Tm$ as its data constructor.
% The goal of the type inference algorithm
% is to find the most general pair, $(\Preds, \tau)$ for a given term $M$ and typing
% environment $\TEnv$. The principal type for this term can then be given as
% $\forall \many{\alpha}. \Preds \then \tau$ where $\many{\alpha}$ are the type variables that appear
% in $\tau$ but not in $\TEnv$. The type inference algorithm indeed might not always succeed.
% The terms for which the type inference does not succeed are called ill-typed terms.
% Ideally, the ill-typed terms would belong to the category of terms which if run would cause the program to crash.

\TODO{Talk about principal type scheme?}
%% Ordering relations on Predicates and Types and constraint types.
% To define the notion of principal typing scheme we need to define the notion of comparing two constraint types.
% We first define an ordering on the predicates by the entailment relation denoted by $\entails$.
% By entailment, we mean that if we have finite sets of predicates, say $\Preds$ and $\MorePreds$, and $\Preds$ holds
% whenever $\MorePreds$ holds, then we say $\MorePreds \entails \Preds$ ($\MorePreds$ entails $\Preds$).
% The ordering would be $\MorePreds \leq \Preds$ as $\MorePreds$ is more
% specific than $\Preds$. The entailment relation needs to satisfy three properties:
% (1) reflexivity ($P \entails P$), (2) transitivity
% (if $\Preds_1 \entails \Preds_2$ and $\Preds_2 \entails \Preds_3$ then $\Preds_1 \entails \Preds_3$).
% We can also define ordering on types where we say a type $\tau_1$ is more general than another type $\tau_2$
% if and only if there exists a substitution such that $\tau_1[\many{\alpha}/\many{\beta}] = \tau_2$.
% We can now give an ordering relation to constraint types on the basis of the values it can inhabit.
% We say that a constraint type $\sigma_2$ is more general that $\sigma_1$ if every instance of $\sigma_2$
% is also an instance of $\sigma_1$ and by abuse of notation we say $\sigma_2 \leq \sigma_1$.
% Intuitively, a type is more general if it can inhabit more values.

%% How can one detect inconsistent class instances in the formalization
\subsection{Instance Validity and Inconsistency Detection}
%% How to formalize classes and instances?
Each typeclass declaration introduces a new relation on types in the type system. With functional dependencies
we introduce some additional constraints that the instances should satisfy.
We need to ensure that the instances declared are compatible
with the functional dependencies associated with the typeclass.
There are two necessary conditions to ensure this:
\begin{enumerate}[topsep={0pt},partopsep={0pt}]
\item\emph{Covering Condition}:  For each new instance declaration !instance $\Preds$ => C t where ...!
  that the user writes, we need to check that,% , for each functional dependency
  % $f =$ (!X -> Y!) $\in \fundep{C}$,
  % $\TV{t_Y} \subseteq \closure{\TV{t_X}}{f}$. Consider the class declarations !class C1 a b | a -> b!
  % and !class C2 a b | b -> a! and an instance declaration,
  % !instance C1 Int x => C2 x Int!. This instance declaration violates the above condition,
  % as !x! cannot be determined by the dependency !b -> a!.
  % It turns out, that this condition is weak\cite{jones_language_2008}.
  % An instance might have additional dependencies induced by the predicates $\Preds$
  % that we need to take into account. A more appropriate check would be
  $\TV{t_Y} \subseteq \closure{\TV{t_X}}{\fundep{{P,C}}}$,
  where $\fundep{{P,C}}$ are the functional dependencies of $C$ and additional dependencies
  induced by the instance context $P$. Intuitively, this condition says that
  all the type variables of the determinant, $\TV{t_Y}$, should either already be in the
  set of dependent type variables, $\TV{t_X}$, or should be fully determined using the
  functional dependencies induced by the class ($\fundep{C}$) or induced by the constraints ($\fundep{P}$).
\item\emph{Consistency Condition}: For each new instance of the form !instance $\MorePreds$ => C s where ...!
  along with !instance $\Preds$ => C t where ...! we need to ensure whenever $t_Y = s_Y$ we also have $t_X = s_X$.
  It is straightforward to check this condition. We first find the most general unifier for $t_X$ and $s_X$,
  say $U$, and then check that $U t_Y = U s_Y$. If we cannot find such a unifier, then we know that
  the instances are consistent. For example, !instance C1 Int a! is consistent with !instance C1 Char a!
  as there is no unifier for !Int! and !Char!. However, !instance Add Int Float Float!
  and !instance Add Int Float Int! are inconsistent.% with an identity unifier.
\end{enumerate}
% Are they sufficient?
% The first is to ensure that the instances that the user writes
% are valid and second for each new instance that the user writes, we need to check that it does not
% contradict the functional dependency.

%% what is an improving substitution, how can we compute it?
\subsection{Computing and Using Improving Substitution}\label{subsec:fd-improve}
An improving substitution, written as $\impr\Preds$, is a substitution that does not change the set of
satisfiable instances of predicate set $\Preds$.
% Thus, if $\Omega = \impr{P}$ then $\satisfyable{P} = \satisfyable{\Omega P}$.
Computing an improving substitution is straightforward with the induced functional
dependencies, $\fundep \Preds$, on the predicate set, $\Preds$.
For each $(X \to Y)\in\fundep{P}$
whenever we have $\TV{t_X}$ we can infer $\TV{t_Y}$. The rational behind
improving substitution is that it helps simplifying the type by showing its true
and concise characterization.
% For example, for a given type !Add Int Float p => p!
% we know that there is a unique choice for !p! due to the functional dependency,
% thus we have an improving substitution $\Omega = [p/Float]$ which
% fixes the seemly polymorphic type variable !p! without changing its indented meaning.
Improving substitutions also affects the way ambiguous types are detected.
For a qualified type, $\forall\many{\alpha}.\Preds\then\tau$, the usual ambiguity
check is $(\many{\alpha}\cap\TV{P}) \subseteq \TV{\tau}$. However, with induced functional dependencies $F_P$
due to $\Preds$, the appropriate check would be $(\many{\alpha}\cap\TV{P}) \subseteq \closure {\TV{\tau}} {F_\Preds}$.
We thus weaken the check to ensure that there might be some type variables $\alpha_i$ that are determined by the
functional dependencies due to the class constraints. This improving substitution can be applied
anywhere during the type inference algorithm without adversely affecting it.


\subsection{Type safety of \TCFD{}}\label{subsec:tcfd-safety}
\newcommand\AppR{
  \ib{\irule[\trule{s-app}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Tm_2} {\Tm'_1\App\Tm_2}}}
}
\newcommand\BetaR{
  \ib{\irule[\trule{s-$\beta$}];
    {\stepsto {(\Lam x \tau \Tm_1)\App\Tm_2} {\Tm_1[x/\Tm_2]}}
  }
}
\begin{figure}[ht]
  \footnotesize  
  \[
    \begin{array}{c c}
      \AppR & \BetaR
    \end{array}
  \]
  \caption[\TCFD Operational Semantics]{Small Step Operational Semantics for \TCFD}
  \label{fig:tcfd-opsem}
\end{figure}

The system that has been described has been in terms of its static semantics.
For the static semantics to be of any real use, we also need to provide an important property
of the system in the spirit of \cite{milner_theory_1978}---``Well typed programs
don't go wrong.''---or if our type system says a program is well typed, then if we run the program,
it should not crash (or get stuck). Before we can formalize type safety, we formalize
what running the program means. We say a term $\Tm$ reduces $\Tm'$ or $\stepsto \Tm {\Tm'}$
using the rules shown in \pref{fig:tcfd-opsem}.
We define $\manystepsto {\bullet} {\bullet}$ as a transitive closure of the $\stepsto{\bullet}{\bullet}$ relation.

\begin{lemma}[Progress \TCFD{}]\label{lem:tcfd-prog}
  If $\QTyping \empt \empt {\Tm_1} \tau$ then $\Tm_1 \in \Val$ or $\stepsto {\Tm_1} {\Tm_2}$.
\end{lemma}

\begin{lemma}[Preservation \TCFD{}]\label{lem:tcfd-preserve}
  If $\QTyping \empt \empt {\Tm_1} \tau$ and $\stepsto {\Tm_1} {\Tm_2}$ then $\QTyping \empt \empt {\Tm_2} \tau$
\end{lemma}
% For preservation, we need to also prove a helper lemma, that says substitution is sound.
% \begin{lemma}[Term Substitution \TCFD{}]\label{lem:tcfd-subst}
%   If $\QTyping \Preds {\TEnv,x\co\tau_2} {\Tm_1} {\tau_1}$ and $\QTyping \Preds \TEnv {\Tm_2} {\tau_2}$ then
%   $\QTyping {\Preds} {\TEnv} {\Tm_1[x/\Tm_2]} \tau_1$
% \end{lemma}

The (syntactic) type safety of the system can formally be given as
\begin{lemma}[Type Safety \TCFD{}]
  If $\QTyping \empt \empt \Tm \tau$ then either $\Tm \in \Val$ or there exists a term, $\Tm'$, such that
  $\manystepsto \Tm {\Tm'}$ and $\Tm' \in \Val$
\end{lemma}


% The idea of functional dependency has been borrowed from the theory of relational
% databases\cite{codd_realtional_1970, amstrong_dependency_1974}. In simple terms,
% an attribute (or a set of attributes) $y$ is said to be dependent
% on another attribute (or a set of attributes) $x$, if in a relation $R$,
% the value (or values) of $x$ uniquely determine the value (or values) of $y$.
% In such a functional dependency, the attribute $y$ is said to be
% the dependent while $x$ is the determinant. To elucidate this analogy
% we use \pref{fig:fd-table}. Each table describes a typeclass
% and its instances. The attributes are typeclass's type parameters.
% Each row is an instance of the typeclass and the set of all the rows in the table
% describe the relation. A slight difference between database tables
% and typeclass tables is that we can have a table of infinite number
% of rows in the latter but not in the former. In this table form,
% it is easy to see that inconsistent instances arise when we have a duplicate
% row for the determinant fixed by the functional dependency.

% \TODO{fix the table column widths using tabularx}
% \begin{figure}[ht]
%   \begin{tabular}[ht]{c c c c}
%     \begin{tabular}[ht]{l}
%       Type class\\
%       \hline
%       FunDeps\\
%       \hline
%       Attributes\\
%       \hline
%       \\
%       Values\\
%       \\
%       \\
%     \end{tabular}&%
%                    \begin{tabular}[ht]{c  c  c}
%                      & Add & \\
%                      \hline
%                      & !m n -> p! &\\
%                      \hline
%                      m & n & p\\
%                      \hline
%                      Int & Int & Int\\
%                      Float & Float & Float\\
%                      Int & Float & Float\\
%                      Float & Int & Float\\
%                    \end{tabular} &%
%                                    \begin{tabular}[ht]{c c c}
%                                      & TEq & \\
%                                      \hline
%                                      !t -> u! && !u -> t!\\
%                                      \hline
%                                      t   && u\\
%                                      \hline
%                                      Int && Int\\
%                                      Z && Z\\
%                                      S Z && S Z \\
%                                      & \ldots  & \\
%                                    \end{tabular}&%
%                                                   \begin{tabular}[ht]{c c c}
%                                                     & Convert & \\
%                                                     \hline
%                                                     \\
%                                                     \hline
%                                                     a   &&  b\\
%                                                     \hline
%                                                     Int && Int\\
%                                                     Int64 && Int64\\
%                                                     Int && Int64\\
%                                                     & \ldots  & \\
%                                                   \end{tabular}
%   \end{tabular}
%   \caption{Class instances as Databases}
%   \label{fig:fd-table}
% \end{figure}

\AI{Should i be talking about open type families?}
\section{Closed Type Families}\label{sec:tf-closed}
Type family is powerful language feature of describing computation on types in a more
natural style of functional programming rather than relations in the style of logic programming.
For example, we can define addition over the two previously mentioned types !Z! and !S n!
as shown in \pref{fig:plus-ty-fam}. This style is a lot more palpable for programmers
who are already used to writing equations with pattern matching at term level.
It also has a cleaner view and has less code clutter compared to functional dependencies.
The vector concatenation !concat_vec! also gets a cleaner and concise type as compared to previous definition.

\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
data TT -- Type level True
data FF -- Type level False
\end{code}&%
\begin{code}
type family TEq n m where
  TEq a a = TT
  TEq a b = FF
\end{code}\\
\begin{code}
type family Plus n m where
Plus Z     m = m
Plus (S n) m = S (Plus n m)
\end{code}&%
\begin{code}
concat_vec :: Vec m e -> Vec n e
           -> Vec (Plus n m) e
concat_vec v1 v2 = $\ldots$
\end{code}
  \end{tabular}
  \caption{Peano Arithmetic and Vector Operations with Closed Type Family}
  \label{fig:plus-ty-fam}
\end{figure}
The !Add m n p! typeclass defined in \pref{fig:add-tc-fd} can also be written in
the type family style as shown in \pref{fig:add-ty-fam}. The change is that the new 
!Add! typeclass takes only two parameters in this setting while the result type
of !(+)! function now returns a special type !Result m n!. This !Result m n! type is defined
for each instance we expect the typeclass !Add! to be defined at.
As expected, the instance !Add Int Float! would raise a type error due to its conflict with
the first type instance. 

% Before we go further, we first need to fix the taxonomy of the building blocks of type family declaration.
% Taking the example of !Plus m n!, the header---!type family Plus m n!--says that we are
% declaring a new type family constructor named !Plus! of arity 2. The equations
% are listed after the !where! keyword. Each equation's left hand side mentions
% the name of the type family and a type pattern, and the right hand side mentions the result type.
% %The type pattern can be thought of as a tuple which may contain type variables. 

\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
type family Result m n where
  Result Int Int = Int   -- (1)
  Result a Float = Float -- (2)
  Result Float a = Float -- (3)

class Add m n where
  (+) :: m -> n -> Result m n

instance Add Int Int where
  (+) = intAdd
\end{code}&%
\begin{code}
instance Add Int Float where
  i + f = addFloat (int2Float i) f

instance Add Float Int where
  f + i = addFloat (int2Float i) f

instance Add Int Float where -- Error
  i + f = addInt i (float2int f)
    \end{code}
  \end{tabular}
  \caption{\texttt{Add} Typeclass using Closed Type Family}
  \label{fig:add-ty-fam}
\end{figure}
The system that supports closed type families (\CLTF{}), is an extension of \FC\cite{sulzmann_system_2007}.
\FC is essentially System F\cite{girard_proofs_1989,reynolds_towards_1974} with type equality coercions.
The type equality coercions are special types, that act as proof or witness
for equality between types. These type coercions are the workhorse of type rewriting;
an essential component to support type level functions.
A notable feature of GHC, an implementation of Haskell, is that it compiles the surface language
to an explicitly type annotated core language based on \FC. The program transformation
passes done after type checking also produce well typed \FC terms. The surface level expression
language for GHC is close to Hindley-Milner language which may not mention any types or coercions.
All the coercions thus have to be inferred by the type checker while compiling
the source language into to core language. 
\begin{figure}[ht]
  \footnotesize
  \TODO{may be don't include this example? but i like them :(}
  \begin{tabular}{l l}
\begin{code}
data Leaf a
data Node a b
\end{code}&%
\begin{code}
type family Or a b where
  Or FF a = a
  Or TT a = TT
  Or a TT = TT
\end{code}\\
\begin{code}
type family TMember e tree where
  TMember e (Leaf e') = TEq e e'
  TMember e (Node lt rt)
    = Or (TMember e lt) (TMember e rt)
\end{code}&%
\begin{code}
type family CountArgs ty where
  CountArgs (a -> b) = S (CountArgs b)
  CountArgs b        = Z
\end{code}
  \end{tabular}
  \caption{Complex Typelevel Functions}
  \label{fig:tf-closed-examples}
\end{figure}

The closedness of type families come from the syntax level restriction
where the programmer is not allowed to add any more equations to the type family once
they are defined. % As evident from the !TEq! example, they can very well be
% used for any new types that may subsequently be defined without any issues. 
The utility of closed type families is further elucidated with the examples
given in \pref{fig:tf-closed-examples}. !CountArgs! computes the number of arguments that a type expects while
!TMember! can be used to check if a given type exists in a complex type data structure.
The advantage of such a restriction is that it makes it easier to define functions on types
that would otherwise need some complex encoding, or a type checker which supports backtracking.

\subsection{Type Matching and Apartness}\label{subsec:tf-closed-apartness}
Intuitively, the semantics of type family declarations is to lift the type family equations into axioms.
Instantiating one of these axiom would give us coercions which can be
used as an evidence for equality between two types. We say that a target type $\tau$
reduces to or evaluates to another type $\tau_1$ when we can
find such an evidence. We say a rule is fired when a certain type family rule is used
to generate a coercion evidence term. % For example, the target type !Int -> Float -> Result Int Float!
% reduces to or evaluates to !Int -> Float -> Float! with the rule !Result a Float = Float! being fired.
before we dive into the formalization of this system, there are some subtle details about
the static semantics of type reduction that we ought to mention.% informally as we need the system to be consistent.

The type rewriting is performed by using a top to bottom target matching procedure,
where the first instance of the left hand side that matches is used to rewrite the type.
This enables the type equations to possibly have have overlapping left hand sides of the equations.  
The type family definition of !TEq a b! indeed has overlapping equations with !Eq a a! and !Eq a b!.
Overlapping equations introduce some complexity in the system, but it also enhances usability. 
There are two restrictions on the type patterns
(1) it should  have the same length as the arity of the type family constructor, and
(2) the type patterns can not have occurrences of type family constructors.
The first condition is necessary to avoid having partially applied type families in our system,
while the second condition is to ensure soundness.

Consider !BadTyFam! shown in \pref{fig:closed-tf-bad}, and a target type
!BadTyFam (TEq Int Bool)!. The last equation is fired in this case and we reduce the target to !FF!.
However, if we instead evaluate !TEq Int Bool! first we get !TT! and the second equation is fired.
This shows that non-determinism in the target matching may introduce unsoundness.
We also need to avoid eager target type reduction as shown with the !boom! example,
that will case a crash at runtime. The crux of the problem is that, if we (erroneously) reduce
!TyFam (TEq Bool d)! we get !()!, as !TEq Bool d! matches the second equation from !TEq a b!,
and it reduces to !FF!. However, in the call to !boom!, we see that !d! is instantiated with !Bool!
thus !TyFam (TEq Bool d)! it should reduce to !Int -> Int!. This is indeed, unsound.
\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
type family BadTyFam a where
  BadTyFam TT        = FF
  BadTyFam FF        = TT
  BadTyFam (TEq x y) = FF
type family TyFam b where
  TyFam TT = Int -> Int
  TyFam FF = ()
\end{code}&%
\begin{code}
fun :: d -> TyFam (TEq Bool d)
fun _ = ()
boom :: Int
boom = fun True 5 -- $\text{\faBomb}$
\end{code}
  \end{tabular}
  \caption{Bad Type Families}
  \label{fig:closed-tf-bad}
\end{figure}
A na\"ive notion of matching where we check for failure for a most general unifier of two types
is not a fool proof mechanism as it can lead to non-confluence and inconsistency in presence of type families.
We instead use the following definition of apartness using type flattening defined below:
\begin{defn}[Type Flattening]\label{def:ctf-flatten}
  We say a type $\tau$ is flattened to $\tau_1$, or $\tau_1 = \flatten{\tau}$, when every
  type family application of the from $\FamCtrs(\many\sigma)$ is replaced by a type variable,
  such that in the flattened type, every syntactically equivalent type family application
  in $\tau$ is replaced by same type fresh type variable and syntactically different type family applications in $\tau$
  are replaced by distinct fresh type variables.
  % For example, if we have a type !$\tau$ = F b c -> F a b -> F a b -> F c b!
  % then $\flatten\tau =$!$\alpha_1$ -> $\alpha_2$ -> $\alpha_2$ -> $\beta$!
  % with $[\alpha_1/\texttt{F b c}, \alpha_2/\texttt{F a b}, \beta/\texttt{F c b}]$.
\end{defn}
Now apartness of types and matching can be defined as:
\begin{defn}[Apart and Matching]\label{def:apart-match-ty}
  We say two types, $\tau_1$ and $\tau_2$ are apart if $\unify{\tau_1}{\flatten{\tau_2}}\fails$ and $\tau_1$ does not
  mention type family constructors and dually, $\match{\tau_1}{\tau_2} = \lnot\apart{\tau_1}{\tau_2}$
\end{defn}
Simplification of type families just by using apartness criterion is too restrictive,
for example if the two equations simplify to the
same right hand side every time they have same left hand sides,
they are sound and we should allow them. For example, the first and third equation in
!Or a b! type family declaration example in \pref{fig:tf-closed-examples} are compatible.
We formalize the notion of compatibility of equations below:
\begin{defn}[Compatible Equations]\label{def:compact-eq}
  The two equations, $p$ and $q$, are compatible
  if there exist two substitutions, $\Subst_1$ and $\Subst_2$ such that
  if $\Subst_1(\lhs{p}) = \Subst_2(\lhs{q})$ then $\Subst_1(\rhs{p}) = \Subst_2(\rhs{q})$.
\end{defn}
Implementing compatibility is simple. For two equations $p$ and $q$, we find $\Subst = \unify{\lhs p, \lhs q}$.
If the call to unification fails, then the equations are compatible vacuously else if we do find a substitution,
we check if $\Subst\rhs p = \Subst\rhs q$. 
\begin{defn}[Closed Type Family Simplification]\label{def:cft-simpl}
  An equation, say $p$, given in the type family declaration can be used to simplify the the
  target $\FamCtrs(\many\tau)$ to a type if the following two conditions hold:
  \begin{enumerate}
  \item The type pattern on left hand side of the equation, $\FamPattern_p$ matches with the
    target $\many\tau$ or $\match{\FamPattern_p}{\many\tau}$
  \item Any equation $q$, that precedes $p$, is either compatible with $p$, $\compat p q$,
    or it's pattern $\FamPattern_q$ is apart, $\apart {\FamPattern_q} {\many\tau}$.
  \end{enumerate}
\end{defn}

\TODO{talk about infitary unification?}

\subsection{Formalizing Closed Type Families}\label{subsec:tf-closed-formal}

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      &\text{Type family Constructors} &\texttt{\FamCtrs},\texttt{\MoreFamCtrs}\\
      &\text{Type Constructors} &\texttt{\TypeCtrs}\\      
      \\
      &\text{Type Validity}               &\ValidType \TEnv \tau\\
      &\text{Proposition Validity}        &\ValidProp \TEnv \Preds\\
      &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      &\text{Context Validity}            &\ValidCtx\TEnv\\
      \\
      &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      \\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau \bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs(\many\tau)&\\
      &\text{Ground Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \Forall\alpha\tau \bnfor \TypeCtrs\many\tau\\
      &\text{Predicates}      &\Preds       &\bnfeq \tau\teq\tau\\
      &\text{Type family Pattern}     &\texttt{\FamPattern} &\bnfeq \many\tau\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      &\text{Coercions}  &\Co,\MoreCo &\bnfeq \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
                                        \bnfor \FamCtrs(\many{\Co}) \bnfor\TypeCtrs(\many{\Co})\\
      &                  &            &\bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
                                        \bnfor \branch{i}{\many\tau} & \\
      \\
      &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
                                        \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau  \\
      &                  &            & \bnfor \DataCtrs\many{e} \\
      &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm\\
      \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom:\AxiomTy
                                        \bnfor \GEnv,\FamCtrs:n \bnfor \GEnv,\TypeCtrs:n\\
      &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,x\co\tau \bnfor \VEnv,\alpha\\
      &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
      % \\
      % &\text{Type family Declaration} & & \texttt{\textbf{type family}}~
      %                                     \FamCtrs\App\many{\alpha}\texttt{\textbf{ where }}
      %                                     \many{F\App\FamPattern = \tau}
    \end{array}
  \]
  \caption[\CLTF{}]{System for Closed Type Families}
  \label{fig:syntax-tf-closed}
\end{figure}
As the surface level language for GHC is too complex to formalize, we will formalize a small portion
of interesting language constructs. The \CLTF has coercion types ($\Co,\MoreCo$), and 
type family constructors ($\FamCtrs$) which are different from type constructors as they differ in their
static semantics. The axiom equations define the type rewriting strategy for a specific $\FamCtrs$.
For example, !TEq! type family looks like $\texttt{AxTEq}: [\forall\alpha.~{\texttt{TEq}~\alpha~\alpha} \teq \texttt{TT}
, \forall\alpha\beta.~{\texttt{TEq}~\alpha~\beta} \teq \texttt{FF}]$.

The typing judgments for terms in this system is a triple $\Typing\TEnv\Tm\tau$ that asserts that
there is a derivation such that term $\Tm$ has type $\tau$ under the typing context $\TEnv$. All the interesting
rules are given in \pref{fig:tf-closed-typing}. The typing environment ($\TEnv$) consists of two contexts,
the variable context ($\VEnv$) which maps free variables to their types, and ground context ($\GEnv$)
that stores all the type rewriting axioms and also necessary information for type and family constructors.
The type validity judgments along with ground context and variable context validity are given
in \pref{fig:tf-closed-validity}. They essentially walk over the context structures
and ensuring we do not add anything invalid and check for type and axiom well formedness by making sure
the context is consistent by using the goodness criterion described above.

\newcommand\ValidTyVar{
  \ib{\irule[\trule{v-tvar}]
    {\alpha\in \VEnv}
    {\ValidCtx{\GEnv;\VEnv}};
    {\ValidType{\GEnv;\VEnv}\alpha}
  }
}
\newcommand\ValidTyCtr{
  \ib{\irule[\trule{v-tctr}]
    {\TypeCtrs \co n \in \GEnv}
    {\ValidCtx{\GEnv;\VEnv}}
    {\many{\ValidType{\GEnv;\VEnv}{\tau_i}}^{i<n}};
    {\ValidType {\GEnv;\VEnv}{\TypeCtrs\many\tau}}
  }
}
\newcommand\ValidTFCtr{
  \ib{\irule[\trule{v-tfctr}]
    {\FamCtrs \co n \in \GEnv}
    {\ValidCtx{\GEnv;\VEnv}}
    {\many{\ValidType{\GEnv;\VEnv}{\tau_i}}^{i<n}};
    {\ValidType {\GEnv;\VEnv}{\FamCtrs\many\tau}}
  }
}
\newcommand\ValidTyArrow{
  \ib{\irule[\trule{v-arr}]
    {\ValidType \TEnv \tau_1}
    {\ValidType \TEnv \tau_2};
    {\ValidType {\TEnv}{(\tau_1\to\tau_2)}}
  }
}
\newcommand\ValidTyFA{
  \ib{\irule[\trule{v-tfa}]
    {\ValidType {\GEnv;\VEnv,\alpha} \tau};
    {\ValidType {\GEnv;\VEnv}{(\Forall\alpha\tau)}}
  }
}

\newcommand\ValidEqProp{
  \ib{\irule[\trule{v-eqp}]
    {\ValidType \TEnv {\tau_1}}
    {\ValidType \TEnv {\tau_2}};
    {\ValidProp \TEnv {\tau_1\teq\tau_2}}
  }
}
\newcommand\ValidTyFamProp{
  \ib{\irule[\trule{v-tfp}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\VEnv,\many\alpha} {N_i}}^{i<n}}
    {\ValidType {\GEnv;\TEnv,\many\alpha} \sigma};
    {\ValidProp {\GEnv;\VEnv} {\Forall{\many\alpha} {\FamCtrs(N) \teq \sigma}}}
  }
}

\newcommand\ValidGndContextEmpt{
  \ib{\irule[\trule{v-gempt}];
    {\ValidGCtx\empt}
  }
}
\newcommand\ValidGndContextTF{
  \ib{\irule[\trule{v-gtf}]
    {\fresh \FamCtrs \GEnv}
    {\ValidGCtx\GEnv};
    {\ValidGCtx{\GEnv,\FamCtrs \co n}}
  }
}
\newcommand\ValidGndContextTC{
  \ib{\irule[\trule{v-gtc}]
    {\fresh \TypeCtrs \GEnv}
    {\ValidGCtx\GEnv};
    {\ValidGCtx{\GEnv,\TypeCtrs \co n}}
  }
}

\newcommand\ValidGndContextAxiom{
  \ib{\irule[\trule{v-gax}]
    {\substack {\ValidGCtx\GEnv\\
               \fresh \Axiom\GEnv}}
    % {\substack {\many{\ValidType {\GEnv;\many{\alpha}_i} {N_i}}^{i<n}\\
    % \many{\ValidType {\GEnv;\many{\alpha}_i} {\sigma_i}}^{i<n}}};
    {\many{\ValidProp{\GEnv;\empt}{\Forall{\many\alpha}{\FamCtrs(\FamPattern)\teq\sigma}}}};
    {\ValidGCtx{\GEnv,\Axiom\co\many{\Forall{\many\alpha}{\FamCtrs(\FamPattern)\teq\sigma}}}}
  }
}

\newcommand\ValidVCtxtEmpt{
    \ib{\irule[\trule{v-vempt}]
    {\ValidGCtx\GEnv};
    {\ValidVCtx\GEnv\empt}
  }
}
\newcommand\ValidVCtxtTVar{
  \ib{\irule[\trule{v-tyvar}]
    {\ValidVCtx\GEnv\VEnv}
    {\fresh\alpha\VEnv};    
    {\ValidVCtx\GEnv{\VEnv,\alpha}}
  }  
}
\newcommand\ValidVCtxtVar{
  \ib{\irule[\trule{v-var}]
    {\ValidVCtx\GEnv\VEnv}
    {\fresh x \VEnv}
    {\ValidType{\GEnv;\VEnv}\tau};
    {\ValidVCtx{\GEnv}{\VEnv,x\co\tau}}
  }    
}

\newcommand\ValidTyCtx{
  \ib{\irule[\trule{v-te}]
    {\ValidVCtx\GEnv\VEnv};
    {\ValidCtx{\GEnv;\VEnv}}
  }
}

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c c}
      \ValidTyVar & \ValidTyArrow & \ValidTyFA\\
    \end{array}
  \]
  \[
    \begin{array}{l l}
      \ValidTyCtr & \ValidTFCtr\\      
    \end{array}
  \]
  \[
    \begin{array}{c c}
      \ValidEqProp & \ValidTyFamProp
    \end{array}
  \]
  \[
    \begin{array}{c c c c}
      \ValidGndContextEmpt & \ValidGndContextTC & \ValidGndContextTF & \ValidGndContextAxiom
    \end{array}
  \]
  \[
    \begin{array}{c c c c}
      \ValidVCtxtEmpt  & \ValidTyCtx & \ValidVCtxtVar & \ValidVCtxtTVar
    \end{array}    
  \]
  \caption{Validity Judgments}
  \label{fig:tf-closed-validity}
\end{figure}

We show the interesting term typing rules in \pref{fig:tf-closed-typing} the rest are standard
and we skip them due to space constraints, except the interesting one \trule{t-cast}.
% As \CLTF is extension of \FC, we have two rules at term level, one for
% type abstraction $\trule{t-tyabs}$ and another for type application $\trule{t-tyapp}$. These
% rules are similar to previously described $\trule{t-abs}$ and $\trule{t-app}$ respectively
% but describe type and term interaction.
It says that a well typed term of type $\tau_1$ can be typed using a new type $\tau_2$
if there is a welltyped witness $\Co$ that casts it from type $\tau_1$ to $\tau_2$.
The three rules $\trule{co-refl}$, $\trule{co-sym}$, and $\trule{co-trans}$ say that the
coercions form an equivalence relation. The four rules $\trule{co-arr}$, $\trule{co-type}$,
$\trule{co-forall}$ and $\trule{co-fam}$ says that if two types are equal then each of
their respective components are also equal, or that they form a congruence relation.
The rules $\trule{co-ntharr}$ and $\trule{co-nth}$ says that we can decompose
type qualities into simpler ones. The rule $\trule{co-inst}$
says that if we have a witness that says two polytypes are equal, then we can obtain a witness
where their respective instantiations with a type are also equal types.

\newcommand\TCast{
  \ib{\irule[\trule{t-cast}]
    {\CoTyping \TEnv \Co {\tau_1\teq\tau_2}}
    {\Typing \TEnv \Tm \tau_1};
    {\Typing \TEnv \Tm \tau_2}}}

\newcommand\TTyAbs{
  \ib{\irule[\trule{t-tyabs}]
    {\ValidType \TEnv \alpha}
    {\Typing {\TEnv,\alpha} \Tm \tau};
    {\Typing \TEnv {\TLam\alpha\Tm} {\Forall\alpha\tau}}}}

\newcommand\TTyApp{
  \ib{\irule[\trule{t-tyapp}]
    {\ValidType \TEnv {\tau_1}}
    {\Typing \TEnv \Tm {\Forall\alpha\tau}};
    {\Typing \TEnv {\Tm\App\tau_1} \tau[\tau_1/\alpha]}}}


\newcommand\CoArr{
  \ib{\irule[\trule{co-arr}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \sigma_1}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \sigma_2}};
    {\CoTyping \TEnv {\Co\to\MoreCo} {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}}}}

\newcommand\CoNthArr{
  \ib{\irule[\trule{co-ntharr$_i$}]
    {\CoTyping \TEnv \Co {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}};
    {\CoTyping \TEnv {\nth i \Co} {\tau_i \teq \sigma_i}}}}

\newcommand\CoForall{
  \ib{\irule[\trule{co-forall}]
    {\CoTyping {\TEnv,\alpha} \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\Forall\alpha\Co} {(\Forall\alpha\tau_1) \teq (\Forall\alpha\tau_2)}}}}

\newcommand\CoInst{
  \ib{\irule[\trule{co-inst}]
    {\ValidType\TEnv\tau}
    {\CoTyping {\TEnv} \Co {\Forall\alpha\sigma_1 \teq \Forall\alpha\sigma_2}};
    {\CoTyping \TEnv {\Co@\tau} {\sigma_1[\alpha/\tau] \teq \sigma_2[\alpha/\tau]}}}}
   
\newcommand\CoRefl{
  \ib{\irule[\trule{co-refl}]
    {\ValidType\TEnv\tau};
    {\CoTyping \TEnv {\refl{\tau}}:\tau\teq\tau}}}

\newcommand\CoSym{
  \ib{\irule[\trule{co-sym}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\sym{\Co}} {\tau_2\teq\tau_1}}}}

\newcommand\CoTrans{
  \ib{\irule[\trule{co-trans}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \tau_3}};
    {\CoTyping \TEnv {\comp \Co \MoreCo} \tau_1\teq\tau_3}}}

\newcommand\CoNth{
  \ib{\irule[\trule{co-nth}]
    {\CoTyping \TEnv \Co {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}};
    {\CoTyping \TEnv {\nth i {\Co}} {\tau_i\teq\sigma_i}}}}

\newcommand\CoTypeCtr{
  \ib{\irule[\trule{co-type}]
    {\TypeCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\TypeCtrs\many\Co} {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}}}}

\newcommand\CoFam{
  \ib{\irule[\trule{co-fam}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\FamCtrs\many\Co} {\FamCtrs\many\tau \teq \FamCtrs\many\sigma}}}}

\newcommand\CoAxiom{
  \ib{\irule[\trule{co-axiom}]
    {\substack {\AxiomTy = \many{\Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}}\\
               \Axiom\co\AxiomTy \in \GEnv}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\ValidCtx{\GEnv;\VEnv}};
    {\CoTyping {\GEnv;\VEnv} {\branch i {\many\tau}} {\FamCtrs (\FamPattern\many{[\alpha_i/\tau_i]}) \teq \sigma\many{[\alpha_i/\tau_i]}}}}}

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c c}
    \TCast   % & \TTyAbs & \TTyApp
    \end{array}
  \]
  \[  
    \begin{array}{c c c}
      \CoRefl & \CoSym & \CoTrans
    \end{array}
  \]
  \[
    \begin{array}{c c}
      \CoArr     & \CoNthArr\\      
      \CoTypeCtr & \CoNth\\
      \CoForall  & \CoInst\\
      \CoFam     & \CoAxiom
    \end{array}
  \]
  \caption[Typing Judgments for \CLTF{}]{Typing Judgments \CLTF{}}
  \label{fig:tf-closed-typing}
\end{figure}

The most interesting rule is the behemoth, $\trule{co-axiom}$ which gives conditions as to
when we can use a particular coercion axiom to rewrite a type. In our example of !TEq!, there are two possible
ways in which the axiom could have been instantiated:
$\texttt{AxTEq}_0[\texttt{Int}]: \texttt{TEq  Int Int} \teq \texttt{TT}$
or $\texttt{AxTEq}_1[\texttt{Int},\texttt{Int}]: \texttt{TEq Int Int} \teq \texttt{FF}$. But the second
option would make the system unsound. The \noconflict{} check saves us from this disaster
by allowing only the first option and rejecting the second.
There are two ways in which the equations are in non-conflicting as shown in \pref{fig:tf-closed-nc}---
1) either the equations are compatible or 2) the equations are apart.

\newcommand\NcApart{
  \ib{\irule[\trule{nc-apart}]
    {\AxiomTy = \many{\FamCtrs(\FamPattern) \teq \sigma}}
    {\apart{\FamPattern_j}{\FamPattern_i[\many\tau/\many\alpha_i]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\NcCompt{
  \ib{\irule[\trule{nc-compt}]
    {\compat {\AxiomTy[i]}{\AxiomTy[j]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\CompatInc{
  \ib{\irule[\trule{compt-inc}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\substack{{\Subst = \unify{\FamPattern_1}{\FamPattern_2}} \\
        {\Subst\sigma_1 = \Subst\sigma_2}}};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}

\newcommand\CompatDist{
  \ib{\irule[\trule{compt-dis}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\Subst = \unify{\FamPattern_1}{\FamPattern_2}\fails};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}
\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c}
      \NcApart & \CompatDist\\
       \NcCompt & \CompatInc
    \end{array}
  \]  
  \caption{Non Conflicting Equations and Compatibility}
  \label{fig:tf-closed-nc}
\end{figure}

\newcommand\TypeRed{
  \ib{\irule[\trule{ty-red}]
    {\substack{\Axiom\co\AxiomTy\in\GEnv\\\ValidGCtx\GEnv}}
    {\substack{\AxiomTy = \many{\Forall{\many\alpha}\FamCtrs(\FamPattern) \teq \sigma}\\ \forall j < i. ~\nc \AxiomTy i {\many\tau} j}}
    {\substack{\Subst=\unify {N_i}{\many\tau}\\\tau_1 = \Subst\sigma_i}};
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_1}}} }
}

\subsubsection{Type Reduction}
We can formally specify type reduction, written as $\tystepsto\GEnv\bullet\bullet$, using
the rule $\trule{ty-red}$. This rule says that the $i$-th equation of axiom $\Axiom$,
$\Forall{\many\alpha}{\FamCtrs(\FamPattern_i) \teq \sigma_i}$ is used to reduce
the target type $\FamCtrs(\many\tau)$ to type $\tau_1$. The \noconflict check is the same as
discussed before and we use $\TEvalCtxt\bullet$ to mean that the rewrite can happen anywhere within the type.
$$
\TypeRed
$$

\subsubsection{Consistency and Goodness of Context}\label{subsec:tf-closed-consistency}
Consistency means that we can never derive unsound equalities between ground types,
such as $\Co:\texttt{Int}\teq\texttt{Bool}$, in the system. Ground types ($\GTy$), in our system are
nothing but $\TypeCtrs\many\tau$, $\tau_1\to\tau_2$ and $\Forall\alpha\tau$.
% In short, they are types that do not contain type family constructors.
% Consistency condition is necessary for our system to have progress property. 
We say that a ground context $\GEnv$ is consistent, when for all coercions $\Co$
such that $\CoTyping {\GEnv;\empt} {\Co} {\GTy_1 \teq \GTy_2}$ we have the following:
\begin{enumerate}
\item if $\GTy_1$ is of the form $\TypeCtrs\many\tau$ then so is $\GTy_2$
\item if $\GTy_1$ is of the form $\tau_1\to\tau_2$ then so is $\GTy_2$
\item if $\GTy_1$ is of the form $\Forall\alpha\tau$ then so is $\GTy_2$
\end{enumerate}
In general context consistency is difficult to prove. We take a conservative approach
and enforce syntactic restrictions on the ground context.
\begin{property}[$\Good~\GEnv$]
  A ground context ($\GEnv$) is $\Good$, written $\Good\GEnv$ when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  where $\AxiomTy$ is of the form $\many{\Forall{\many\alpha}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$ and none of the type pattern $\FamPattern_i$ mentions a type family constructor.
  \item The binding variables $\many\alpha$ occur at least once in the type pattern $\FamPattern$,
    on the left hand side of the equation.
    %Don't need them as we don't have open type families in this system
  % \item If the axiom has multiple equations then, there should be no more than one $\Axiom$
  %   in the context that mentions axioms for a fixed family constructor.
  % \item If the axiom has only one equation, say $\AxiomTy$, is of the form $\AxiomEq_1$,
  %   and there exists another axiom in the context
  %   also with one equation $\AxiomEq_2$ that also mentions the same type family constructor, then
  %   it should be the case that $\compat{\AxiomEq_1}{\AxiomEq_2}$.
  \end{enumerate}
\end{property}
Given our characterization of type reduction in the previous section, we now have to show
that if we have $\Good\GEnv$ then, $\GEnv$ is consistent. One way to prove this is
via confluence of type reduction relation. Whenever we have $\tystepsto \GEnv {\tau_1} {\tau_2}$
then we would know that $\tau_1$ and $\tau_2$ have a common reduct, say $\tau_3$. As type reduction
relation $\trule{ty-red}$ only works on type family's and does not reduce any ground type heads,
confluence would be sufficient prove consistency. However, to prove confluence, it is necessary to assume
termination of type reduction. We get our consistency lemma as follows.
\begin{lemma}[Consistency]
  If $\tystepsto \GEnv \bullet \bullet$ is terminating and $\Good\GEnv$ then $\GEnv$ is consistent.
\end{lemma}

\subsection{Type safety of \CLTF{}}\label{subsec:tf-closed-safety}
\newcommand\SApp{
  \ib{\irule[\trule{s-app}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Tm_2} {\Tm'_1\App\Tm_2}}}
}
\newcommand\STApp{
  \ib{\irule[\trule{s-tapp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\tau} {\Tm'_1\App\tau}}}
}

\newcommand\SCApp{
  \ib{\irule[\trule{s-capp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Co} {\Tm'_1\App\Co}}}
}

\newcommand\SCast{
  \ib{\irule[\trule{s-cast}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\cast{\Tm_1}\Co} {\cast{\Tm'_1}\Co}}}
}

\newcommand\SBeta{
  \ib{\irule[\trule{s-$\beta$}];
    {\stepsto {(\Lam x \tau \Tm_1)\App\Tm_2} {\Tm_1[x/\Tm_2]}}
  }
}
\newcommand\STBeta{
  \ib{\irule[\trule{s-T$\beta$}];
    {\stepsto {(\TLam \alpha \Tm)\App\tau} {\Tm[\alpha/\tau]}}
  }
}

\newcommand\SPush{
  \ib{\irule[\trule{s-push}]
    {\Co_1 = \sym{\nth 0 \Co}}
    {\Co_2 = \nth 1 \Co};
    {\stepsto {(\cast {\Lam x \tau \Tm} \Co) \App \Tm_1} {\cast {(\Lam x \tau \Tm)\App(\cast{\Tm_1} {\Co_1})} {\Co_2}}}
  }
}
\newcommand\STPush{
  \ib{\irule[\trule{s-tpush}];
    {\stepsto {(\cast {\TLam \alpha \Tm} \Co) \App \tau} {\cast {(\TLam \alpha \Tm)\App\tau} {\Co@\tau}}}
  }
}
\newcommand\STrans{
  \ib{\irule[\trule{s-trans}];
    {\stepsto {\cast {(\cast \Tm \Co)} \MoreCo} {\cast \Tm {\comp\Co\MoreCo}}}
  }
  
}

As our system has a variety of new terms, we give a new definition
of the $\stepsto \bullet \bullet$ relation using the rules given in \pref{fig:tf-closed-steps}.
Similar to the previous \pref{subsec:tcfd-safety}, we should have type safety for \CLTF which
includes proving preservation and progress.

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c c c}
      \SApp & \STApp & \SCApp & \SCast
    \end{array}
  \]
  \[
    \begin{array}{c c c}
      \SBeta & \STBeta & \STrans
    \end{array}
  \]
  \[
    \begin{array}{c c}
      \SPush & \STPush
    \end{array}
  \]  
  \caption{Small Step Operational Semantics \CLTF}
  \label{fig:tf-closed-steps}
\end{figure}

For proving preservation lemma, we would have to prove term substitution lemma which, in turn,
will require that substitutions in coercions are sound. This is given by coercion substitution lemma.
\begin{lemma}[Coercion Subst]\label{lem:coercion-subst}
  If $\CoTyping {\GEnv;\VEnv,\alpha,\VEnv'} {\Co} {\Preds}$ and $\ValidType {\GEnv;\VEnv} \tau$
  then, $\CoTyping {\GEnv;\VEnv,\VEnv'} {\Co[\alpha/\tau]} {\Preds[\alpha/\tau]}$
\end{lemma}
The most interesting case would be to prove $\trule{c-axiom}$ case, but the restrictions
due to \noconflict{} will be enough.

\begin{lemma}[Preservation \CLTF]
if $\Typing \empt \Tm \tau$ and $\stepsto \Tm {\Tm'}$ then $\Typing \empt {\Tm'} \tau$
\end{lemma}

To have progress property, it is necessary to have consistency which assumes termination of type reduction.
\begin{lemma}[Progress \CLTF]
  If $\Typing {\Sigma;\empt} \Tm \tau$ and $\tystepsto \Sigma \bullet \bullet$ is terminating,
  then either $\Tm \in \Val$, or $\Tm$ is a coerced value of the form $\cast {\Tm'} \Co$ where $\Tm'\in\Val$
  or there exists a $\Tm_1$ such that $\stepsto \Tm {\Tm_1}$.
\end{lemma}

\section{Constraint Type families}\label{sec:tf-constrained}
In the previous section for closed type families, we have made an implicit assumption---
the type families are all total, in the sense their domain is all the types.
This is problematic in theory as as well as in practice.
Consider the case where a closed type family does not have an equation for a particular type argument
as shown in \pref{fig:incomplete-tyfam}. We know that !PTyFam Bool!
has no satisfying equations associated with it that gives it a meaning and never will in the future
as it is closed. In our current setup a program that diverges---!loopy!---can be given
this nonsensical type and much worse, the system treats it like a valid type.
\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
type family PTyFam a where
  PTyFam Int = Bool
type family Loop where
  Loop = [Loop]
\end{code}&%
\begin{code}
loopy :: $\forall$ a. a
loopy = loopy
sillyFst x = fst (x, loopy :: PTyFam Bool)
sillyList x = x : x
\end{code}
  \end{tabular}
  \caption{Partial Closed Type Family}
  \label{fig:incomplete-tyfam}
\end{figure}

Next, consider the target type !TEq [a] a!, in \CLTF, this type is not evaluated to
!FF! even though ![a]! and !a! don't have no most general unifier. The reason being there
may be an infinite type such as !Loop! that does unify both ![a]! and !a!. As
!Loop! unwinds infinitely to become ![[[$\ldots$[Loop]$\ldots$]]]! we will have
!TEq [Loop] Loop! evaluate to !TEq [Loop] [Loop]! which is !TT!. This justifies the
reason for not evaluating !TEq [a] a! to !FF!. However, Haskell does not have infinite ground types,
and we thus would expect !TEq [a] a! to reduce to !FF!.
The crux of the problem here is that we treat type families as they are type constructors (ground types).
!Loop! will never reduce to a ground type but we must treat it like one while trying to reduce !TEq [a] a!.
This non-uniform treatment of type family constructors is confusing for programmers.

There also seems to be a mismatch in our intuitive semantics of type families. We think
of them as partial functions on types where each new equation extends its definition. Instead
we should be thinking about them as introducing a family of distinct types and
each new equation equates types that were previously not equal. This distinction in semantics
does matter in practice as illuminated by !sillyList!. If !Loop! is a type then we
can give !sillyList! a type that is !Loop -> Loop!. But this is not its principle type,
as we can generalize it to be  !(a ~ [a]) => a -> a!. Haskell however rejects this program
on the basis of infinitary unification of !a ~ [a]! is not possible. We are left in a position
where we accept some problematic definitions, like !Loop!, but not the others like, (!a ~ [a]!).
To solve this problem we leverage the existing infrastructure that Haskell already has---qualified
types and typeclasses---to make the totality assumption explicit.

% One possible solution to this conundrum is to reject the definition of infinite type families
% like !Loop!. This would however burden the programmers by enforcing a provision of an evidence
% to guarantee termination we thus defer going in that direction.
% Instead,

\subsection{Closed Typeclasses}
Typeclasses can be extended to have new instances. Closed typeclasses, on the contrary,
are classes that will not be able to be extended once they are defined. They essentially
mirrors closed type families in the sense the programmer cannot add more instances after they
are defined. We can define overlapping instances for a closed typeclass and their resolution
will be performed at operator's use site in a top to bottom order on instance declarations.

For example, the type families !TEq a b! and !Plus m n! can be expressed
in the closed typeclass world using !TEqC a b! and !PlusC m n! respectively as shown in \pref{fig:closed-tc-examples}.
\begin{figure}[ht]
    \footnotesize
  \begin{tabular}{l l}
\begin{code}
class LoopC where
  type Loop
  instance LoopC => LoopC where
    type Loop = [Loop]
\end{code}&%
\begin{code}
class PTyFamC a where
  type PTyFam a
  instance PTyFamC Int where
    type PTyFam Int = Bool
\end{code}\\    
\begin{code}
class {-TOTAL-} TEqC a b where
  type TEq a b
  instance TEqC a a where
    type TEq a a = TT
  instance TEqC a b where
    type TEq a b = FF  
\end{code}&%
\begin{code}
class {-TOTAL-} PlusC m n where
  type Plus m n
  instance PlusC Z m where
    type Plus Z m = Z
  instance PlusC m n => PlusC (S m) n where
    type Plus (S m) n = S (Plus m n)  
\end{code}
  \end{tabular}
  \caption{Closed Typeclasses Examples}
  \label{fig:closed-tc-examples}
\end{figure}
In the constrained type families world, every closed type family will be associated with
a closed typeclass. Any type family without an associated typeclass will be disallowed.
For example, see !class PTyFamC!. The type for !sillyFst! in this system is no longer
!$\forall$ a. a -> a! but instead it is !$\forall$ a. PTyFamC Bool => a -> a!, and the type
checker will flag it as an error wherever it is used; there is no way to satisfy
the instance !PTyFamC Bool!. The type family !Loop! will also need to have
an associated typeclass !LoopC!. To declare an instance of !LoopC!
where !Loop ~ [Loop]! we need to specify !LoopC! to be a constraint on the instance.
This makes the use of !Loop! no longer threatens the type soundness as !LoopC! is unsatisfiable.

Most type families are partial, only some are total and we would want
the users to take advantage of this fact by allowing programmers to specify it.
In general checking for or inferring totality for a given closed type family is a hard problem, thus
we would also give the users a way to let the type checker accept it without checking it.
It would otherwise be inconvenient to express total type families. 

\subsection{Type matching and Apartness Simplified}
The type rewriting in closed type families had a complex criterion for apartness that included
flattening and then checking if they had a unifier using infinitary unification. In constrained type families
we neither have to depend on infinitary type unification nor flattening of types. We can
also relax the restriction that type families cannot appear in the left hand side
of the type rewrite equations due to the class constraints associated with
the use of each type family constructor. The constraint of allowing only terminating
type families can also be lifted as seen from the !LoopC! example, it no longer
threaten type soundness. Apartness in this system is just checking for failure of unification.

\subsection{Formalizing Constrained Type Families}\label{subsec:tf-constrained-formal}
This system is similar to \CLTF except for a few new constructors that
we highlight in \pref{fig:tf-constrained-system}. The ground context keeps track of
two types of type family constructors, a total type family constructor of arity $n$ (written $\FamCtrs\co_\top n$)
and a partial type family constructor of arity $n$ (written $\FamCtrs\co n$).
The variable environment ($\VEnv$) along with variable type bindings
also stores coercion constraint bindings $c\co\Preds$.
Each equation that is introduced by axioms ($\Axiom$) in this system,
are of the form $\Forall {\many\alpha~\many\chi}{\FamCtrs(\many\tau)\teq\sigma}$.
Both $\many\tau$ and $\sigma$ do not have occurrence of any family type constructors. 
The equations are quantified by type variables $\many\alpha$
and also over a new term collection evaluation assumptions $\many\chi$.
These evaluation assumptions are of the form $\alpha|c\co\FamCtrs(\many\tau)\teq\alpha$ and read as
``$\alpha$ such that $c$ witnesses $\FamCtrs(\many\tau)$ reduces to $\alpha$''.
We use these evaluation assumptions to allow type families on the left hand side
of the type equations written in the source program. For example,
the user written type equation  !F (F' a) = G a!, where $G$ and $F'$ are type family constructors,
will be compiled into an equation $\forall a~(b|c:G~a \teq b)(d|c:F'~a \teq d).~ F(d) \teq b$.
% Evaluation assumptions are essential to support axioms that mention
% type families on the right hand side of the equations in source.
We use $\chi$ to remind us that it is more specific than $\Preds$; for any $\chi$,
the left hand side of the type equality is always a type family and right and side is a fresh variable.
The $\tassume\chi\Tm$ is the construct that is used while working with total type families.
It provides a sort of an escape hatch as we are guaranteed to obtain a type family free type
after reducing a total type family.

The ground types in this system can mention type family constructors only in propositions $\Preds$.
For example, the type !$\forall$m n. Add m n => m -> n -> Result m n! would instead be written
as !$\forall$m n. Result m n ~ p => m -> n -> p!. This is an assertion that !Result m n! evaluates to a
type family free type.

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      % &\text{Type family Constructors} &\texttt{\FamCtrs}\\
      % &\text{Type Constructors} &\texttt{\TypeCtrs}\\      
      % \\
      &\text{Type Validity}               &\ValidType \TEnv \tau\\
      &\text{Proposition Validity}        &\ValidProp \TEnv \Preds\\
      &\text{Assumption Validity}      &\ValidAssmp \TEnv {\many\chi}\\
      &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      &\text{Context Validity}            &\ValidCtx\TEnv\\
      \\
      &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      &\text{Resolution Validity}      &\ResTyping \TEnv {\many q} {\many\chi}\\
      \\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau \bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs(\many\tau)
                                              \bnfor \text{\shaded{$\Preds\then\tau$}}&\\
      &\text{Ground Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \Forall\alpha\tau \bnfor \TypeCtrs(\many\tau)\\
      &\text{Predicates}      &\Preds       &\bnfeq \tau\teq\tau\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \text{\shaded{$\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau) \teq \sigma$}}}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      &\text{Coercions}  &\Co,\MoreCo &\bnfeq c \bnfor \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
                                        \bnfor \FamCtrs(\many{\Co}) \bnfor \TypeCtrs(\many{\Co})\\
      &                  &            & \bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
                                        \bnfor \text{\shaded{$\Co_1\teq\Co_2\then\MoreCo$}}
                                        \bnfor \text{\shaded{$\qbranch{i}{\many\tau}{\many q}$}} & \\
      &\text{Eval Assumption}   &\chi &\bnfeq \text{\shaded{$(\alpha|c : \FamCtrs\many\tau \teq \alpha)$}} \\
      &\text{Eval Resolution}   &q    &\bnfeq \text{\shaded{$(\tau|\Co)$}}\\      
      \\
      &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
                                        \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau \bnfor\DataCtrs\many{e} \\
      &                  &            & \bnfor \text{\shaded{$\Lam c \Preds \Tm$}} \bnfor \text{\shaded{$\Tm\App \Co$}}
                                        \bnfor \text{\shaded{$\tassume\chi\Tm$}} \\
      &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm \bnfor
                                        \text{\shaded{$\Lam c \Preds \Tm$}}\\
      \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom\co\AxiomTy
                                        \bnfor \text{\shaded{$\GEnv,\FamCtrs\co_\top n$}} \bnfor \GEnv,\FamCtrs\co n
                                        \bnfor \GEnv,\TypeCtrs \co n\\
      &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,\alpha \bnfor \VEnv,x\co\tau
                                        \bnfor \text{\shaded{$\VEnv,c\co\Preds$}}\\
      &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
    \end{array}
  \]
  \caption[Constrained Type Families System]{System for Constraint Type Families}
  \label{fig:tf-constrained-system}
\end{figure}

The new validity judgments reflect the above discussion. The rule \trule{v-qty} ensures
that type equality coercions can appear only in $\Preds$. We do not have the rule \trule{v-tfctr}
in this system to ensure ground types do not mention type family constructors.
The rule \trule{v-qtfp} replaces the rule \trule{v-tfp}. This means that arguments to type family
constructors can mention type families and we no longer have to use special type patterns as in \CLTF's \trule{v-tfp}.
The rule \trule{v-qgax} replaces the \trule{v-gax} that checks axiom equations are valid. This checks that the context
is consistent by making sure it is \Good, as discussed in \pref{subsubsec:tf-constrained-goodness-consistency}.
We also have two new classes of validity judgments, \trule{v-assmn} and \trule{v-assmc} check
that the evaluation assumptions that appear in the axioms are valid, while rules \trule{v-rese}
and \trule{v-resc} ensure that the evaluation resolutions are valid.

\newcommand\ResNil{
  \ib{\irule[\trule{v-rese}]
    {\ValidCtx \TEnv};
    {\ResTyping \TEnv \empt \empt}
  }
}
\newcommand\ResCons{
  \ib{\irule[\trule{v-resc}]
    {\ValidType \TEnv \sigma}
    {\CoTyping \TEnv \Co {\FamCtrs(\many\tau)\teq\sigma}}
    {\ResTyping \TEnv {\many q} {\many\chi[\alpha/\sigma]}};
    {\ResTyping \TEnv {(\sigma|\Co), \many q} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha), \many \chi}}
  }
}

\newcommand\ValidQGndContextAxiom{
  \ib{\irule[\trule{v-qgax}]
    {\substack {\ValidGCtx\GEnv\\
        \fresh \Axiom\GEnv}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i,\TV{\many\chi}} {\tau_{0i}}}}\\
        {\many{\ValidProp{\GEnv;\empt}{\Forall{\many\alpha}{\FamCtrs(\many\tau)\teq\sigma}}}}}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i} {\many\tau_i}}}\\
      {\ValidAssmp {\GEnv;\many\alpha_i} {\many\chi_i}}}}
    {\FamCtrs\co n \in \GEnv};
    {\ValidGCtx{\GEnv,\Axiom\co\many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau_i)\teq\tau_{0i}}}^{i<k}}}
  }
}

\newcommand\ValidNilAssmp{
  \ib{\irule[\trule{v-assmn}];
    {\ValidAssmp \TEnv \empt}}
}

\newcommand\ValidConsAssmp{
  \ib{\irule[\trule{v-assmc}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}^{i<n}}
    {\ValidAssmp {\GEnv;\VEnv,\alpha} {\many\chi}};
    {\ValidAssmp {\GEnv;\VEnv} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha),\many\chi}}}
}
\newcommand\ValidQType{
  \ib{\irule[\trule{v-qty}]
    {\ValidProp \TEnv \Preds}
    {\ValidType \TEnv \tau};
    {\ValidType \TEnv {\Preds\then\tau}}}
}
\newcommand\ValidQTyFam{
  \ib{\irule[\trule{v-qtfp}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\TEnv} {\tau_i}}^{i<n}}
    {\ValidType {\GEnv;\VEnv} \sigma};
    {\ValidProp {\GEnv;\VEnv} {\FamCtrs(\many\tau)\teq\sigma}}}
}


\newcommand\ValidQCoVar{
  \ib{\irule[\trule{v-qcovar}]
    {\ValidVCtx\GEnv\VEnv}
    {\ValidProp {\GEnv;\TEnv} \Preds}
    {\fresh c \VEnv};    
    {\ValidVCtx\GEnv{\VEnv,c\co\Preds}}
  }  
}


\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c c}
      \ValidQType & \ValidQTyFam\\
      \ResNil & \ResCons\\
      \ValidNilAssmp & \ValidConsAssmp
    \end{array}
  \]
  \[
    \begin{array}{c c}
        \ValidQGndContextAxiom &      \ValidQCoVar 
    \end{array}
  \]
  \caption{Validity Judgments for \QLTF}
  \label{fig:tc-constrained-validity}
\end{figure}


\newcommand\QCoAbs{
  \ib{\irule[\trule{t-coabs}]
    {\Typing {\TEnv,c\co\Preds} \Tm \tau};
    {\Typing \TEnv {\Lam c \Preds \Tm} {{\Preds\then\tau}}}}}

\newcommand\QCoApp{
  \ib{\irule[\trule{t-coapp}]
    {\Typing \TEnv \Tm {\Preds \then \tau}}
    {\Typing \TEnv \Co {\Preds}};
    {\Typing \TEnv {\Tm\App\Co} \tau}}}

\newcommand\QAssume{
  \ib{\irule[\trule{t-assum}]
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}}
    {\FamCtrs\co_\top n \in \GEnv}
    {\Typing {\GEnv;\VEnv,\alpha,c\co\FamCtrs\many\tau\teq\alpha} \Tm {\tau}};
    {\Typing {\GEnv,\VEnv} {\tassume{(\alpha|c\co\FamCtrs\many\tau\teq\alpha)}\Tm} \tau}}}


\newcommand\QCoAxiom{
  \ib{\irule[\trule{co-qaxiom}]
    {\substack {{\Axiom\co\AxiomTy \in \GEnv}\\
        {\AxiomTy = \many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau) \teq \sigma}}}}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\substack {\ValidCtx {\GEnv;\VEnv}\\
        \ResTyping {\GEnv;\VEnv} {\many{q}} {\many\chi[\alpha_i/\tau_i]} }};
    {\CoTyping {\GEnv;\VEnv} {\qbranch i {\many\tau} {\many q}} {\FamCtrs (\many\sigma\many{[\alpha_i/\tau_i]}) \teq \sigma_0\many{[\alpha_i/\tau_i]}}}}
}

\newcommand\QCoQual{
  \ib{\irule[\trule{co-qual}]
    {\many{\Typing \TEnv {\Co_i} {\tau_i\teq\sigma_i}}^{i<3}};
    {\CoTyping \TEnv {\Co_1\teq\Co_2 \then\Co_3} {(\tau_1\teq\tau_2\then\tau_2)\teq(\sigma_1\teq\sigma_2\then\sigma_3)}}}}

\newcommand\QCoVar{
  \ib{\irule[\trule{co-var}]
    {c\co\Preds \in \VEnv};
    {\Typing {\GEnv;\VEnv} {c} \Preds}}
}

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}[ht]{c c}
      \QCoVar & \QCoAxiom\\
      \QCoAbs & \QCoQual \\
    \end{array}
  \]
  \[
    \begin{array}{c c c}
      \QCoApp & \QAssume
    \end{array}
  \]
  \caption[Selected Typing Judgments for \QLTF]{Selected Typing Judgments \QLTF{}}
  \label{fig:tf-constrained-typing}
\end{figure}

The typing judgments new to this system are shown in \pref{fig:tf-constrained-typing}.
The rule \trule{t-coabs} abstracts over coercion variable while \trule{t-coapp} applies a coercion
argument to a term. We have a new version of axiom application rule \trule{co-qaxiom}.
It is very similar to \trule{co-axiom}, except that we need
to provide extra validity resolutions $\many q$ that instantiate the validity assumptions $\many\chi$.
The validity resolutions are of the form $(\tau|\Co)$ where the type $\alpha$
in validity assumptions $(\alpha|c\co\FamCtrs(\many\tau)\teq\sigma)$ is instantiated to $\tau$ and
$\Co$ proves the equality and instantiates $c$. This is exactly what the rule \trule{v-resc} does.
% We write $[\chi/q]$ for a substitution where the assumption $\chi$ is substituted by $q$.
Finally, The rule \trule{t-assum} is the special rule that says we are allowed to assume arbitrary applications
of a type family would give us a type free type. We can indeed do this by the definition of total type family.

\subsubsection{Type reduction}
The type reduction relation is given using two rules \trule{qty-red-top} and \trule{qty-red}.
The rule \trule{qty-red-top} does the heavy lifting of producing the correct substitutions
for types ($\Subst_1$) as well as evaluation resolutions ($\Subst_2$). The correct
equation selection is done by $\noconflict$ criterion.
The specialty of this relation is that we ensure applying type arguments to type families only when
they satisfy proper constraints with the use of evaluation resolutions,
thus guaranteeing every type reduction to eventually obtain a type family free type.
And due to the fact that type family free types do not reduce, we can prove termination,
for the type reduction relation.
\newcommand\QTyRed{
  \ib{\irule[\trule{qty-red}]
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1} };
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_1}}} }
}
\newcommand{\QTyTopRed}{
  \ib{\irule[\trule{qty-red-top}]
    {\substack{ {\Axiom\co\AxiomTy\in\GEnv}\\
        {\ValidGCtx\GEnv}\\
        {\AxiomTy_i = \Forall{\many\alpha_i~\many\chi_i}\FamCtrs(\many{\sigma_i}) \teq \sigma_0}\\
        {\forall j < i. ~\nc \AxiomTy i {\many\tau} j}
      }}
    {\substack {{\many\chi_i = \many{(\alpha'|c\co\MoreFamCtrs(\many\tau')\teq\alpha')}}\\
        {\tystepsto \GEnv {\many{\MoreFamCtrs(\Subst_1\many\tau')}} \many{\tau_0}}}}
    {\substack {{\Subst_1 = \mgu{\many\sigma_i}{\many\tau}}\\
        {\Subst_2 = [\many{\chi_i}/\many{\MoreFamCtrs(\Subst_1\many\tau')\teq\tau_0}]}\\
        {\tau_1 = \Subst_1\Subst_2\sigma_0}\\
      }};
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1}} }
}  

\begin{figure}[ht]
    \footnotesize
  \[
  \begin{array}[ht]{c c}
    \QTyRed & \QTyTopRed
  \end{array}
  \]
  \caption{Type reduction}
  \label{fig:tc-constrained-tyred}
\end{figure}


\subsubsection{Goodness and Consistency}\label{subsubsec:tf-constrained-goodness-consistency}
The definition of Goodness can now be relaxed due to simplifying apartness criteria for types.
\begin{property}[$\Good~\GEnv$ relaxed]
  A ground context ($\GEnv$) is $\Good$, written $\Good\GEnv$ when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  where $\AxiomTy$ is of the form $\many{\Forall{\many\alpha~\many\chi}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$.
  \item The binding variables $\many\alpha$ occur at least once in the type arguments $\many\tau$,
    on the left hand side of the equation.
  \end{enumerate}
\end{property}
With the reduction relation defined in previous section, and knowing that it is always terminating,
we can use Newman's lemma\cite{newman_theories_1942} to prove that type reduction is confluent.
Thus we get our relaxed consistency lemma as follows:
\begin{lemma}[Consistency] If $\Good\GEnv$ then $\GEnv$ is consistent \end{lemma}

\subsection{Type safety of \QLTF}\label{subsec:tf-constrained-safety} 
\newcommand\TQPush{
  \ib{\irule[\trule{t-qpush}]
    {\substack {{v = \Lam c \Preds \Tm}\\
        {\MoreCo_0 = \nth 0 \MoreCo}}}
    {\substack {{\MoreCo_1 = \sym{\nth 1 \MoreCo}}\\
        {\MoreCo_2 = \nth 2 \MoreCo}}};
    {\stepsto {(\cast v \MoreCo)\App \Co} {\cast {v\App(\comp{\comp{\MoreCo_0}{\Co}}{\MoreCo_1})} \MoreCo_2}}
  }
  }

\newcommand\TQResolve{
  \ib{\irule[\trule{t-qres}]
    {\chi = (\alpha|c\co\FamCtrs(\many\tau)\teq\alpha)}
    {\FamCtrs(\many\tau) \Downarrow q};
    {\stepsto {\tassume\chi\Tm} {e[\chi/q]}}}
}

\newcommand\TQBeta{
  \ib{\irule[\trule{t-c$\beta$}];
    {\stepsto {(\Lam c \Preds \Tm)\App\Co } {\Tm[c/\Co]}}}
}
Selected rules for term evaluation are shown in \pref{fig:tf-constrained-opsem}.
The rule \trule{t-qres} evaluates a constraint function application similar to function application
while the rule \trule{t-qpush} splits the inner coercion $\MoreCo$ so that it can be commuted with
the coercion application $\Co$. The rule \trule{t-qres} is the rule that illuminates the evaluation
for total type family constructors. The clause $\FamCtrs(\many\tau) \Downarrow q$ says that we
find a witness for $\FamCtrs(\tau)$ reduction to a ground type to build an appropriate evaluation resolution
and apply it to the enclosing term.
\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{c c c}
      \TQResolve & \TQBeta & \TQPush
    \end{array}
  \]
  \caption{Small Step Operational Semantics \QLTF}
  \label{fig:tf-constrained-opsem}
\end{figure}
We can thus state the preservation and progress for this system as follows:
\begin{lemma}[Preservation \QLTF]
  If $\Typing \empt \Tm \tau$ and $\stepsto \Tm {\Tm'}$ then $\Typing \empt {\Tm'} \tau$
\end{lemma}
\begin{lemma}[Progress \QLTF]
  If $\Typing {\Sigma;\empt} \Tm \tau$
  then either $\Tm$ is a value, or $\Tm$ is a coerced value of the form $\cast {\Tm'} \Co$ where $\Tm'\in\Val$
  or there exists a $\Tm_1$ such that $\stepsto \Tm {\Tm_1}$.
\end{lemma}


% \section{Related Work}\label{sec:related-work}
% Functional dependencies have also been formalized using constraint handling rules (CHR),
% a technique from logic programming\cite{sulzmann_understanding_2007}. There is no known
% implementation of functional dependencies using CHR.

% There are several variations of type families that have been explored and implemented in GHC.
% Open type families\cite{schrijvers_type_2008}, which predates closed type families,
% are extendable in a sense that the programmer can add more equations.
% To maintain both, extensibility and compatibility, open type families disallow overlapping equations.
% A system with both closed type families and open type families can co-exist without hiccups. This is
% indeed the current implimentaion of GHC. The semantics of the instance equations is similar to
% that of unordered collection of type equations, unlike
% closed type families, where the equations are considered in a top to bottom fashion.
% Associated types\cite{chakravarty_associated_2005} are a syntactic variation of open type families.
% Each typeclass has an associated type parameterized over typeclass parameters. Each instance of such typeclass
% specifies what the associated type's interpretation in the context. Injective type families\cite{stolarek_injective_2015}
% uses the idea from functional dependencies to specify additional injective constraints that the type family instance
% should satisfy to aid type inference.

\section{Conclusion and Future Work}\label{sec:conclusion}
% All three systems described in the paper have a common property that they are based on
% the principle of type erasure. The type analysis is performed at compile time and
% the types are erased from the programs at runtime.
% This ensures that there is no runtime overheads because of types.
% Due to type safety properties of each of these systems, we are guaranteed
% that if a program passes the type check then it does not crash at runtime.
% A feature that we have not included in each of the systems is the system of kinds, or type of types.
% They provide a way to have partially applied data constructors. The reason to not include them is that
% they are orthogonal to our discussion. Adding them to the system will not change type safety of the language.

% With squinting eyes, typeclasses with functional dependencies and type families are trying to achieving the
% same goal---computation on types. While functional dependencies have a flavor of relations,
% type families have a flavor of equations. Haskell programmers using GHC,
% prefer functional programming over logic programming making type families their preferred choice.
% Further, a buggy implementation of functional dependencies in GHC, does not help its case either.
% A formal proof about the equality of the expressive power of functional dependencies and
% type families is an open problem\cite{TODO}. 

Type computation, either using functional dependencies or type families
is an attractive feature for programmers as it considerably improves language expressivity.
If functional dependencies are morally equivalent to type families
one would expect to have either of the two cases to be true
1) translation mechanism that can go from one style to another or 2)
translation of both the language features into a common intermediate language.
As of now both of these remain an active area or research\cite{karachalias_elaboration_2017,sulzmann_understanding_2007}.

The type safety formalization of closed type families hinges on the assumption that
type family reduction are terminating. This problem is effectively solved by using constrained type families.
In conclusion, the motivation of constraint type families is to reunite
the idea of functional dependencies and type families that had previously diverged.
The use of equality constraints to ensure that type family applications are well defined
is reminiscent of the use of functional dependencies to ensure typeclass instances are well defined.
\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{typeclasses}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
