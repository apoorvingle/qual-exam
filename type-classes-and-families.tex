%% FIXME:
%% 1. Space hacking for definitions and list items
%% 2. Tables and array looks
%% 3. Shaded box with \shaded

\newif\ifcomments\commentstrue

\RequirePackage[svgnames,dvipsnames,prologue]{xcolor}

\documentclass[format=acmsmall,manuscript,review,screen,nonacm,margin=1in,11pt]{acmart}

\usepackage{typeclasses}

\title{Dialects for Type Computations}
% \subtitle{Typeclasses, functional and Type Families}
\author{Apoorv Ingle}
%\orcid{0000-0002-7399-9762}
\affiliation{%
  \institution{University of Iowa}
  \department{Department of Computer Science}
  \streetaddress{McLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
% \keywords{typeclass, type family}

\begin{document}
\begin{abstract}
  Static types have two advantages: (1) they serve as a guiding tool
  to help programmers write correct code, and (2) the typechecker
  can help identify code that does not behave correctly.
  An expressive type system can guarantee stronger claims about programs.
  Type level computations make the type system more expressive.
  In Haskell, there are two styles of type level computation---functional dependencies
  and type families. In this report we describe these two language features with examples,
  formalize, and compare them.
\end{abstract}
\maketitle
%\pagestyle{plain}

\section{Introduction}
Parametric polymorphism is a powerful technique that allows programs to work on
a wide variety of types. The identity function, !id!, that takes an input and returns it
without modification has the type !$\forall$$\alpha$. $\alpha$ -> $\alpha$!,
We read this type as follows: for all types, !$\alpha$!, if the argument is of type !$\alpha$!
then the function returns a value of type !$\alpha$!.
We also need to tame unconstrained polymorphism.
A division function on all types does not make sense. We cannot
divide a function that multiplies two numbers by a function that adds two numbers.
The type !$\forall$ $\alpha$. ($\alpha$ $\times$ $\alpha$) -> $\alpha$!, that accepts
a pair of values of type !$\alpha$!, and returns the first component divided by the
second component is too general to describe division. A constrained polymorphic type,
!$\forall$ $\alpha$. (Dividable $\alpha$) => ($\alpha$ $\times$ $\alpha$) -> $\alpha$!,
more accurately describes the functions intention. Intuitively, the predicate,
!Dividable $\alpha$!, means: only those types that satisfy this predicate
have a meaningful divide function. Typeclasses\cite{wadler_polymorphism_1989} give a mechanism
of having such constrained polymorphic types. Theory of qualified types\cite{jones_qualified_1994}
formalizes typeclasses and justifies constrained polymorphism
without compromising type safety by having predicates as a part of type syntax.

A typeclass also defines relations on types. This gives programmers a way to
encode computations at type level. However, using relations to encode type computations
is cumbersome. A new language feature, type families\cite{schrijvers_towards_2007}, was introduced in Haskell
to enable type functions. They are stylistically more obvious for functional programmers.
Naturally, the type families feature warrants a richer system of types, and reasoning about type safetiness
for such systems is nontrivial.

The scope of the current article is as follows:
we first give examples of typeclasses in the beginning of \pref{sec:tc},
and then describe functional dependencies\cite{jones_tcfd_2000} with some examples in \pref{sec:fd}.
We formalize them in \pref{subsec:tc-formal} and describe their consequences in \pref{subsec:fd-improve}.
We have a brief discussion about associated types as a way to have type functions in \pref{sec:assoc-types}.
We then describe two flavors of type families---closed type families\cite{eisenberg_typefamilies_2014}
in \pref{sec:tf-closed} and constrained type families\cite{morris_typefamilies_2017}
in \pref{sec:tf-constrained} with examples.
We formalize the important parts of both the systems in \pref{subsec:tf-closed-formal}.
and \pref{subsec:tf-constrained-formal} respectively.
To conclude we point towards some open questions in \pref{sec:conclusion}.
For presenting code examples, we will be using a Haskell\cite{haskell_2010} syntax.

\section{Typeclasses}\label{sec:tc}
Typeclasses can be thought of as collection of types. Each typeclass is accompanied by its member
functions that all the instances ought to support. For example,
equality can be expressed as a typeclass !Eq a! as follows:\newline
{
  \footnotesize
  \begin{tabularx}{\textwidth}{X X X}
\begin{code}^^J
class Eq a where^^J
\ \ (==) :: a -> a -> Bool^^J
\end{code}&%
\begin{code}^^J
instance Eq Int where^^J
\ \ a == b = primEQInt a b^^J
\end{code}&%
\begin{code}^^J
instance Eq Char where^^J
\ \ a == b = primEQChar a b^^J
\end{code}
  \end{tabularx}
}
The instances of !Eq! typeclass can be types such as integers (!Int!) and characters (!Char!) but
defining equality on function types (!a->b!) is not meaningful. The operator
!(==)! is not truly polymorphic: it cannot operate on function types. Rather
it is constrained to only those types that have an !Eq! instance defined.
We make this explicit in the type of the operator !(==)!, by saying it's defined
only on those types !a! that satisfy the !Eq a! predicate,
or !(==) :: $\forall$a. Eq a => a -> a -> Bool!. The reading for this type is: for any type !a! that
satisfies the predicate !Eq a!, if we are given two
values of type !a!, then we can return a Boolean value indicating if the two arguments are equal.

%% What are these?
There is nothing special about typeclasses having just one type parameter. 
A multiparameter typeclass with $n$ type parameters represents a relation on $n$ types.
An example of such a typeclass, !Add a b c! is shown in \pref{fig:multip-typeclass}.
It represents a relation of types !a!, !b! and !c! such that adding values of type !a! and type !b!
gives us a value of type !c!. The type of the operator, !(+)!, that performs this add operation will be
!$\forall$a b c. Add a b c => a -> b -> c!. Instances of such a typeclass would be !Add Int Int Int!,
!Add Int Float Float!, and so on.
\begin{figure}[ht]
  \footnotesize
  \begin{tabularx}\textwidth{c c c}
\begin{code}^^J
class Add m n p where^^J
\ \ (+) :: m -> n -> p^^J
\end{code}&%
\begin{code}^^J
instance Add Int Float Float where^^J
\ \ (+) a b = addFloat (toFloat a) b^^J
\end{code}&%
\begin{code}^^J
instance Add Int Int Int^^J
\ \ (+) a b = intAdd a b^^J
\end{code}
  \end{tabularx}
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
instance Add Int Float Int where^^J
\ \ (+) a b = addInt a (toInt b)^^J
\end{code}&%
\begin{code}^^J
expr :: (Add Int Float b, Add b Int c) => c^^J
expr = (1 + 2.5) + 3^^J
\end{code}
  \end{tabularx}
  \caption{Multiparameter Typeclasses}
  \label{fig:multip-typeclass}
\end{figure}

%% What problems do they introduce?
Although more expressive, multiparameter typeclasses are difficult to use in practice.
Suppose the programmer defines two instances: !Add Int Float Float! and !Add Int Float Int!
and writes an term !expr = (1 + 2.5) + 3!.
Due to the use of the operator !(+)! in !expr!, its most general type synthesized
by the type inference algorithm will be !$\forall$ b c. (Add Int Float b, Add b Int c) => c!.
Notice how the type variable !b! occurs only in the predicate set !(Add Int Float b, Add b Int c)!.
Such types are called ambiguous types and the type variables, such as !b!,
are called ambiguous type variables. Ambiguous types do not have well defined semantics in Haskell.
The compiler cannot choose a unique interpretation of the subterm !(1 + 2.5)! as it can very well be
of the value !4! of type !Int! or the value !2.5! of type !Float!.
One way to solve this is to use defaulting rules. This behaviour is problematic
as that the programmer now has ensure the interaction of impicit defaulting
rules do not cause problems. Haskell, thus, disallows ambiguous types by reporting a type error.
These type errors, however, are not user friendly; although the issue can be attributed
to conflicting instances of typeclass !Add m n p!, the type error is raised at the term
which may be defined in a different location.

\section{Functional Dependencies with Examples}\label{sec:fd}
\begin{figure}[ht]
  \footnotesize
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
class Add m n p | m n -> p where^^J
\ \  (+) :: m -> n -> p^^J
\end{code}&%
\begin{code}^^J
instance Add Int Float Float where^^J
\ \  $\ldots$^^J
^^J
instance Add Int Float Int where -- Error!^^J
\ \  $\ldots$^^J
\end{code}
  \end{tabularx}
  \caption{\texttt{Add m n p} with Functional Dependency and Conflicting Instances}
  \label{fig:add-tc-fd}
\end{figure}

%% How does this solve the previous problem
Typeclasses with functional dependencies\cite{jones_tcfd_2000} is a generalization of multiparameter typeclasses.
It introduces a new syntax where the user can specify a dependency between the type parameters
in the typeclass declaration. There is no change in the syntax of declaring instances.
!Add m n p! typeclass, as shown in \pref{fig:add-tc-fd}, now has a functional dependency
between the type parameters such that types !m! and !n! determine the type !p!.
In general we can have multiple parameters on both sides of the arrow,
(!$x_1$, ..., $x_m$ -> $y_1$, ..., $y_m$!). We write !X -> Y! to mean
``the parameters \texttt{X} uniquely determine the parameters \texttt{Y}''.

The programmer can use functional dependencies to specify the intention of the typeclasses
more accurately, and in turn it gives the compiler a way to detect and report inconsistent instances.
For example, the functional dependency on !m n -> p!
can now help the typechecker flag the instance !Add Int Float Int! to be in conflict with the instance
!Add Int Float Float! which was indeed the real intention of the typeclass.

Further, we may also be able to determine the ambiguous type variables using the functional dependencies.
Let's reconsider the ambiguous type of term !e! from the previous section, we can now determine
that !b! has to be !Float!. It is determined by the types !Int! and !Float! of the class instance.
Thus, !expr :: (Add Int Float Float, Add Float Int c) => c!.
We can even go a step further and improve this seemingly polymorphic type.
The type variable !c! can be determined to be !Float!, giving us the type !expr :: Float!.
It would be impossible to make such an improvement without the functional dependency.

\begin{figure}[ht]
  \footnotesize
  \begin{tabular}{l l}
\begin{code}
data Z   -- Type level Zero
data S n -- Type level Successor
\end{code}&%
\begin{code}
class IsPeano c
instance IsPeano Z
instance IsPeano n => IsPeano (S n)
\end{code}\\
\begin{code}
class Plus m n p | m n -> p
instance IsPeano m => Plus Z m m
instance Plus n m p => Plus (S n) m (S p)
\end{code}&%
\begin{code}
data Vector s e = Vec (List e)
concat_vec :: Plus m n p
     => Vector m e -> Vector n e -> Vector p e
concat_vec (Vec l1) (Vec l2)
     = Vec (append l1 l2)
\end{code}
  \end{tabular}
  \caption{Peano Arithmetic and Vector Operations with Functional Dependencies}
  \label{fig:peano-arith}
\end{figure}

With functional dependencies at our disposal, we can even perform Peano arithmetic at type level,
as shown in \pref{fig:peano-arith}. The two datatypes !Z! and !S n!
represent the number zero and successor of a number !n!, respectively.
The instances of !IsPeano! assert that: !Z! is a peano number, and if !n! is a peano number
then !S n! is a Peano number. The instances of !Plus! typeclass relates three peano numbers such that the relation
holds if the first two peano numbers add up to be equal to the third. Thus, !Peano Z m m! asserts the relation
!0 + m = m!, and !Plus n m p => Plus (S n) m (S p)! asserts that if n + m = p then (1 + n) + m = (1 + p).
The !concat_vec! function demonstrates why type level computation would be useful
for a linear algebra library. The type of !concat_vec! says that the size of the resulting
vector is the sum of the sizes of the argument vectors.
The above examples are meant to demonstrate how functional dependencies help in encoding
type level functions that multiparameter type classes cannot not due to absence of the capability
to restrict the class relation that the programmer needs.

\subsection{Formalizing Typeclasses with Functional Dependencies}\label{subsec:tc-formal}
% \TODO{start here. Why do we need to formalize? how should incoherence/ambiguity be formalized? How does functional
%   dependency prevent that?}
In previous sections we made a case for why ambiguous types are problematic and how
functional dependencies can help us solve it. We now formalize this intuition to make our claim precise.
We organize the our language as shown in \pref{fig:tcfd-syntax} and call it \TCFD.
The types ($\tau$) consist of type variables ($\alpha$), functions ($\tau\to\tau$), and type constants
($\TypeCtrs$) such as !Int!, !Float! etc. The qualified types ($\rho$) are $\Preds\then\rho$
where $\Preds$ constrains the type $\rho$. Type schemes ($\sigma$) are quantified constraint types.
The terms or expressions in the language ($\Tm$) consists term level variables ($x, y$),
functions ($\Lam x \tau e$), function applications ($e_1\App e_2$).

\begin{figure}[ht]
    \small
  \[
  \begin{array}{l l l}
    &\text{Type Variables}     &\alpha, \beta\\
    &\text{Term Variables}     &x, y\\
    &\text{Class Constructors} &\ClassCtrs\\
    &\text{Type Constants}  &\TypeCtrs\\    
    \\
    &\text{Term Typing}        &\QTyping \Preds \TEnv \Tm \tau\\
  \end{array}
  \begin{array}{l l l l}
    &\text{Predicates}      &\pi               &\bnfeq C\many{\tau}\\
    &\text{Predicate Set}   &\Preds,\MorePreds &\bnfeq \many\pi\\
    &\text{Types}           &\tau              &\bnfeq \alpha \bnfor \tau\to\tau \bnfor \TypeCtrs\\
    &\text{Qualified Types} &\rho              &\bnfeq \tau \bnfor \Preds\then\tau\\
    &\text{Type Schemes}    &\sigma            &\bnfeq \forall{\many\alpha}.\rho\\
    &\text{Terms}           &\Tm               &\bnfeq x \bnfor \Tm\App\Tm \bnfor \Lam x \tau \Tm\\
    &\text{Values}          &\val              &\bnfeq \Lam x \tau \Tm
    \\
    &\text{Typing Environment} &\TEnv &\bnfeq \empt \bnfor \TEnv,x\co\sigma
  \end{array}
  \]
  \caption[\TCFD]{\TCFD}
  \label{fig:tcfd-syntax}
\end{figure}

\subsubsection {Notations}\label{subsubsec:tcfd-notations}
We will use notations as follows. Subscripts on objects
($\alpha_1,\ldots, \alpha_n$) are used to distinguish them.
A collection of $\alpha_1, \alpha_2, ..., \alpha_n$ items of arbitrary length is written as $\many\alpha$
We use $S_1 \setdiff S_2$ to denote the set difference operation. For an object $X$,
$\TV{X}$ is the set of type variables that are free in $X$.
We write $[\many{x}\mapsto\many{y}]\Tm$ to denote the substitution where each variable
$x_i$ is mapped to $y_i$ in $\Tm$. Alternatively, we also
write $\Subst X$ for an substitution $\Subst$ applied to object $X$.
We denote the most general unifier for two types $\tau_1$ and $\tau_2$ (if it exists),
by $\mgu{\tau_1}{\tau_2}$\cite{robinson_machine-oriented_1965}.
We write $\mgu{\many{\tau_1}}{\many{\tau_2}}$ to give us a composition of most general
unifier for each pair of types $(\tau_{1i}, \tau_{2i})$.
% We abbreviate the $\ClassCtrs\many\alpha$ as $\Preds$ and $\MorePreds$

For a typeclass declaration we write !class $\Preds$ => $\ClassCtrs$ t!, where !t! are the type parameters
of the class and $\Preds$ are the constraints that must be satisfied, and for an instance of typeclass
$\ClassCtrs$, we write !instance $\Preds$ => $\ClassCtrs$ t!, where length of !t!
matches the typeclass arity with additional constraints on !t! are introduced by $\Preds$.
We denote the set of functional dependencies of class !C! with $\FunDep{C}$.
For an arbitrary functional dependency !$X$ -> $Y$! the determinant of a functional dependency
is denoted by $t_{X}$ and the dependent is denoted by  $t_{Y}$.
For example, for a typeclass declaration !class Add m n p | m n -> p!,
we have, $t = (m, n, p)$, $\FunDep{Add}=$!$\{$ m n -> p $\}$!.
For the functional dependency !m n -> p!, we have, $t_X = {(\texttt{m},\texttt{n})}$ and $t_Y = {(\texttt{p})}$.
Given a set of functional dependencies $\texttt{J}$, we define the closure operation,
$\closure Z {\texttt{J}}$, on $Z \subseteq t$, to be equal to all the type parameters
that are determined by set of the functional dependencies \texttt{J}.
Thus, $\closure {\Set{m}} {\FunDep{Add}} = \Set{m}$ and $\closure {\Set{m, n}} {\FunDep{Add}} = \Set{m, n, p}$.

\subsubsection{Type System}\label{subsubsec:tcfd-system}
The typing environment $\TEnv$ is a mapping between term variables to types
such that a term variable appears at most once. We write $\dom{\TEnv}$ to mean
the set of all term variables in $\TEnv$ i.e. $\Set{x \mid (x\co\tau) \in \TEnv}$.
We denote $\TEnv_x$ to be $\TEnv$ obtained after removing the binding for $x$ (if it existed) in $\TEnv$.
The typing judgements are of the form $\QTyping \Preds \TEnv \Tm \sigma$.
They assert existence of a typing derivation that shows $\Tm$ has type $\sigma$
with predicates $\Preds$ being satisfied and the free variables in $\Tm$
are given types by the typing environment $\TEnv$.
The typing rules that build these typing derivations in our system are shown
in \pref{fig:tcfd-typing} that we will go over next.
\newcommand\TPAbs{
  \ib{\irule[\trule{$\I\then$}]
    {\QTyping {\Preds,\MorePreds} \TEnv \Tm \rho};
    {\QTyping \Preds \TEnv \Tm {\MorePreds\then\rho}}}
}

\newcommand\TPApp{
  \ib{\irule[\trule{$\E\then$}]
    {\QTyping \Preds \TEnv \Tm {\MorePreds\then\rho}}
    {\ent \Preds \MorePreds};
    {\QTyping \Preds \TEnv \Tm \rho}}
}

\newcommand\TAbs{
  \ib{\irule[\trule{$\I\to$}]
    {\QTyping \Preds {\TEnv_x, x\co\tau_1} {\Tm} {\tau_2}};
    {\QTyping \Preds \TEnv {\Lam x {\tau_1} \Tm} {\tau_1 \to \tau_2}}}
}
 
\newcommand\TApp{
  \ib{\irule[\trule{$\E\to$}]
    {\QTyping \Preds \TEnv {\Tm_1} {\tau_2 \to \tau}}
    {\QTyping \Preds \TEnv {\Tm_2} {\tau_2}};
    {\QTyping \Preds \TEnv {\Tm_1\App\Tm_2} {\tau}}}
}

\newcommand\TVar{
  \ib{\irule[\trule{var}]
    {x\co\sigma \in \TEnv};
    {\QTyping {\Preds} {\TEnv} {x} {\sigma}}}
}

\newcommand\TForallI{
  \ib{\irule[\trule{$\I\forall$}]
    {\QTyping \Preds \TEnv \Tm \rho}
    {\alpha\not\in\TV\TEnv \cup \TV\Preds};
    {\QTyping \Preds \TEnv \Tm {\Forall{\alpha}\rho}}
  }
}

\newcommand\TForallE{
  \ib{\irule[\trule{$\E\forall$}]
    {\QTyping \Preds \TEnv \Tm {\Forall\alpha\rho}}
    {\beta~\text{fresh}};
    {\QTyping \Preds \TEnv \Tm {[\alpha\mapsto\beta]\rho}}
  }
}

\begin{figure}[ht]
  \centering
  \small
  \[
    \begin{array}{c}
      \TVar \\
      \TAbs \\
      \TApp \\          
    \end{array}
    \begin{array}{c}
      \TForallI\\
      \TForallE\\
      \TPAbs\\   
      \TPApp\\   
    \end{array}
  \]
  \caption{Typing judgments for \TCFD{} Terms}
  \label{fig:tcfd-typing}
\end{figure}

The left column lists the standard term typing rules.
Each term is associated with one typing rule that specifies when the term is well typed.
The rule \trule{var} says that if the variable $x$ has type $\sigma$ then
typing environment $\TEnv$ should contain that binding to confirming.
The rule \trule{$\I\to$} says that if a term, $\Tm$, has type $\tau_2$
with a free variable $x$ of type $\tau_1$ then the term $\Lam x {\tau_1} \Tm$
has a type $\tau_1 \to \tau_2$. The rule \trule{$\E\to$} justifies function application
that says if a term (function) $\Tm_1$ is of type $\tau_1 \to \tau_2$
and another term (argument) $\Tm_2$ is of type $\tau_2$, then the term $\Tm_1\App\Tm_2$ is of type $\tau_2$.

The right column contains rules that involve the predicate set of the typing judgement.
The rule \trule{$\I\forall$} generalizes the type and the rule \trule{$\E\forall$} instantiates it.
It is necessary for $\beta$ to be a fresh type variable to ensure it doesn't clash with
existing free type variables. The rule \trule{$\I\then$} moves the global predicate $\MorePreds$
in to constrain the type $\rho$ while the \trule{$\E\then$} moves the constraint
out of the type $\rho$. The condition $\Preds\entails\MorePreds$,
read as ``$\Preds$ entails $\MorePreds$'', means that
whenever $\MorePreds$ is satisfied $\Preds$ is also satisfied.
The theory of qualified types\cite{jones_qualified_1994} mandates the entailment relation to
satisfy the three following properties:
\begin{enumerate}
\item Reflexivity: $\Preds\entails\Preds$
\item Transitivity: if $\Preds\entails\MorePreds_1$ and $\MorePreds_1\entails\MorePreds_2$
  then $\Preds\entails\MorePreds_2$
\item Regularity: if $\Preds\entails\MorePreds$ then $\Subst\Preds\entails\Subst\MorePreds$
\end{enumerate}
In this case, a predicate $\pi$, of the form $\ClassCtrs\many\tau$, is satisfied
when we can find a typeclass instance. The above three properties indeed hold for this specific
formulation of predicate satisfiability.

\subsection{Improving Substitution and Ambiguous Types}\label{subsec:fd-improve}
The typing rules shown in \pref{fig:tcfd-typing} does not included the use of functional dependencies.
We will now formalize it using an extra typing rule \trule{impr} that we motivate below.

\newcommand\Impr{
  \ib{\irule[\trule{impr}]
    {\QTyping \Preds \TEnv \Tm \rho}
    {\Subst = \impr{\Preds\cup\rho_\MorePreds}};
    {\QTyping {\Subst\Preds} {\Subst\TEnv} \Tm {\Subst\rho}}
  }
}
$$
\Impr
$$

An improving substitution, written as $\impr{\Preds}$, is a substitution that does
not change the set of satisfiable instances of predicate set $\Preds$. 
The rational behind improving substitution is that it helps simplifying
the type by showing its true and concise characterization.
Computing an improving substitution, in \TCFD, is to find if any type variables,
can be determined using the functional dependency given in the predicate set.
For each functional dependency, !X -> Y!, induced by the predicate set, $\Preds$, or
$(X \to Y)\in\FunDep{P}$, for a particular class $\texttt{C t} \in \Preds$,
whenever we know $\TV{t_X}$, then we can determine $\TV{t_Y}$.
The notation $\rho_\MorePreds$ stands for the predicate set $\MorePreds$ for a the
qualified type $\rho$ of the form $\MorePreds\then\tau$.
For example, in case of !expr :: (Add Int Float b, Add b Float c) => c!,
the improvement substitution, $[b\mapsto\texttt{Float}, c\mapsto\texttt{Float}]$,
obtained by using the functional dependency, $\FunDep {Add} = \Set{\texttt{m n} \to \texttt{p}}$,
gives us the improved type !Float!.


We can also modify detection of ambiguous types.
For a qualified type, $\forall\many{\alpha}.\Preds\then\tau$, the usual ambiguity
check is $(\many{\alpha}\cap\TV{P}) \subseteq \TV{\tau}$. However,
with induced functional dependencies $\FunDep P$ due to $\Preds$,
the appropriate check would be $(\many{\alpha}\cap\TV{P})
\subseteq \closure {\TV{\tau}} {\FunDep \Preds}$. We weaken the check
as there can be some type variables which are determined
by the functional dependencies induced by the class constraints.
% An improving substitution can very well be a trivial identity substitution
% when there are no type variables to improve on.
% Computing it may also fail which would mean that we have a predicate
% set that is unsatisfiable and the term can be flagged as an illtyped term.

%% How can one detect inconsistent class instances in the formalization
\subsection{Instance Validity and Inconsistency Detection}
Every typeclass introduces a new realtion on types. With functional dependencies,
we have additional constraints which every instances should satisfy.
We need to ensure that the instances declared are compatible
with the functional dependencies associated with the typeclass.
There are two necessary conditions to ensure this:
\begin{enumerate}[topsep={0pt},partopsep={0pt}]
\item\emph{Covering Condition}:  For each new instance declaration !instance $\Preds$ => C t where ...!
  that the programmer writes, we need to check that,% , for each functional dependency
  $\TV{t_Y} \subseteq \closure{\TV{t_X}}{\FunDep{{P,C}}}$,
  where $\FunDep{{P,C}}$ are the functional dependencies of $C$ and additional dependencies
  induced by the instance context $P$. Intuitively, this condition says that
  all the type variables of the dependent, $\TV{t_Y}$, should either already be in the
  set of determinant type variables, $\TV{t_X}$, or they should be fully determined using the
  functional dependencies induced by the class ($\FunDep{C}$) or the functional dependencies
  induced by the constraints ($\FunDep{P}$). For example, for a typeclass declaration
  !class C a b |  a -> b! the instance declaration !instance C Int a! fails the coverage test,
  while !instance C a Int! passes it.
\item\emph{Consistency Condition}: For each new instance of the form !instance $\MorePreds$ => C s where ...!
  along with !instance $\Preds$ => C t where ...! we need to ensure whenever $t_Y = s_Y$ we also have $t_X = s_X$.
  It is straightforward to check this condition. We first find the most general unifier for $t_X$ and $s_X$,
  say $U=\mgu {t_X}{s_X} $, and then check that $U t_Y = U s_Y$. If we cannot find such a unifier, then we know that
  the instances are consistent. For example, !instance C1 Int a! is consistent with !instance C1 Char a!
  as there is no unifier for !Int! and !Char!. However, !instance Add Int Float Float!
  and !instance Add Int Float Int! are inconsistent.% with an identity unifier.
\end{enumerate}

\section{Associated Types}\label{sec:assoc-types}
Another way to express type computation is by having the typeclass with
a special associated type\cite{chakravarty_associated_2005}.
In this style, each instance of the typeclass specifies how the associated type should be interpreted.
For example, Peano arithmetic can be expressed using !PlusC m n! typeclass with an associated type
!Plus m n! as shown in \pref{fig:plus-assoc-type}.
\begin{figure}[ht]\centering
  \footnotesize
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
class PlusC m n where^^J
\ \ type Plus m n^^J
^^J
instance PlusC Z n where^^J
\ \ type Plus Z n = Z^^J
\end{code}&%
\begin{code}^^J
instance PlusC m n => PlusC (S m) n where^^J
\ \  type Plus (S m) n = S (Plus m n)^^J
^^J
concat_vec :: Vec m e -> Vec n e^^J
\ \ \ \ \ \ \ \-> Vec (Plus n m) e^^J
\end{code}
  \end{tabularx}
  \caption{Plus as an Associated Type}
  \label{fig:plus-assoc-type}
\end{figure}

The type !Plus m n! has two interpretations due to the two typeclass instances,
!Plus Z n  = Z! means $0 + n = 0$, while !Plus (S m) n = S (Plus m n)! means $(1 + m) + n = 1 + (m + n)$. 
The associated type can be viewed as a type function; depending on the use context
one of the interpretations would be picked.
The type of !concat_vec! changes as !Plus n m! is now a type.
We no longer specify this in the predicate set of the type and
it does not have a relational style reading. As visible from the code snippet,
attractiveness of this style is that type computation is
no longer limited in the predicates.

An enthusastic programmer might now try write a type function for type equality
using a typeclass with an associated type as shown below.
We use !TT! and !FF! to represent type level true and false respectively while
the associated type !TEq a b! will be used to compute if the two types !a! and !b! are equal.

{\footnotesize\centering
  \begin{tabularx}\textwidth{X X X}
% \begin{code}^^J
% data TT -- True^^J
% data FF -- False^^J
% \end{code}&%
\begin{code}^^J
class TEqC a b where^^J
\ \ type TEq a b^^J
\end{code}&%
\begin{code}^^J
instance TEqC a a where^^J
\ \ type TEq a a = TT^^J
\end{code}&%
\begin{code}^^J
instance TEqC a b where -- Error^^J
\ \ type TEq a b = FF^^J
\end{code}
  \end{tabularx}
}\\
To the programmers disappointment this definition is rejected by the type system.
The presence of both instances !TEqC a a! and !TEqC a b! is conflicting due to their overlap.
Two instances overlap when both instances provide a match while resolving a constraint.
For example, both the instances !TEqC a a! and !TEqC a b! can be used to match the constraint
!TEqC Int Int!. There is no way for the compiler to choose one instance over the other.
Haskell rejects programs that have overlapping instances as it assumes
that there can only be a unique typeclass instance that matches the constraint.

\section{Closed Type Families}\label{sec:tf-closed}
Closed type family is a generalization of associated typeclasses. We notice from
the above !PlusC m n! typelcass example that we could separate out the associated type !Plus m n!
into its own entity and collect each of its type equations defined by the instance together as shown below.
{\footnotesize
\begin{tabularx}\textwidth{X X X}
&\begin{code}^^J
type family Plus n m where^^J
\ \ Plus Z     m = m^^J
\ \ Plus (S n) m = S (Plus n m)^^J
\end{code}&
\end{tabularx}
}

We call this declaration a type family as it can be thought of as a family of types indexed by the type parameters.
In our case, the type family !Plus m n! has two equations, each corresponding to the two, previously
discussed, instances of the typeclass. This style of writing type functions is palatable
for functional programmers. It resembles a familiar notion of writing term level equations with pattern matching.
\begin{figure}[ht]
\centering\small
\begin{tabularx}{\textwidth}{X X}
\begin{code}^^J
type family Result m n where^^J
\ \  Result Int   Int = Int^^J
\ \  Result a     Float = Float^^J
\ \  Result Float a = Float^^J
^^J
class Add m n where^^J
\ \  (+) :: m -> n -> Result m n^^J
^^J
instance Add Int Int where^^J
\ \  (+) = intAdd^^J
\end{code}&%
\begin{code}^^J
instance Add Int Float where^^J
\ \  i + f = addFloat (int2Float i) f^^J
^^J
instance Add Float Int where^^J
\ \  f + i = addFloat (int2Float i) f^^J
^^J
instance Add Int Float where -- Error^^J
\ \  i + f = addInt i (float2int f)^^J
\end{code}
\end{tabularx}
\caption{\texttt{Add} Typeclass using Closed Type Family}
\label{fig:add-ty-fam}
\end{figure}
The !Add m n p! typeclass defined in \pref{fig:add-tc-fd} can also be written in
a closed type family style as shown in \pref{fig:add-ty-fam}. The change is that the new 
!Add! typeclass takes only two parameters in this setting while the result type
of !(+)! function now returns a special type !Result m n!. This !Result m n! type is defined
for each instance we expect the typeclass !Add! to be defined at.
The second typeclass instance !Add Int Float! would raise a type error due to
its overlap with the first typeclass instance. Even if the compiler did accept overlapping
instances, the expected type of the operator !(+)! will not match the type of the term; the type 
!Result Int Float! always reduces to type !Float!.
% We will write $\stepsto{\tau_1}{\tau_2}$ to mean
% the type $\tau_1$ reduces to $\tau_2$, for example, !Result Int Float $\rightsquigarrow$ Float!
\subsection{Type Matching, Apartness and Reduction}\label{subsec:tf-closed-apartness}
The role of type famlies is to compute the representation type by instantiating the type indices during
type checking phase. In the !Add! example, the representation type of !Result Int Float!
is !Float! while, the representation type of !Plus Z m! is !Z!. The semantics of equations have certain subtleties.
Reduction of an occurance of a type family in a type signature is done using a top to bottom matching technique.
The first equation that matches is used, or fired, for reduction. For example, the type !Add Float Float! matches with the
second equation !Add a Float!---!Int! and !Float! don't match---to reduce to !Float!.
The substitution $[a\mapsto\texttt{Float}]$, which does the trick,
can be computed using the most general unifier function $\mgu {a} {\texttt{Float}}$.\\
{\footnotesize
  \begin{tabularx}{\textwidth}{X X X}
&\begin{code}^^J
type family TEq a b where^^J
\ \ TEq a a = TT^^J
\ \ TEq a b = FF^^J
\end{code}&%
\end{tabularx}
}\\
The real advantage of closed type families over associated types,
is the ability to express type functions that were previously not possible
such as !TEq a b! as shown above. Fixing the order of equation matching
liberates us from the restriction of having non-overlapping equations;
the type !TEq Int Int! will be matched with the first equation.

Now, let us consider the function !funTrick!, as shown in \pref{fig:closed-tf-tricky}.
The type !Tricky a! matches the second equation and reduces to !Bool!.
This reduction will, however, can crash the program, !$\text{\faBomb}$!, which uses !funTrick!
and instantiates !d! to !Bool!, and !Tricky Bool! in turn reduces to !Int -> Int!.
Type inconsistency bugs, which cause runtime crashes, can be introduced while using overlapping equations
and a na\"ive type reduction strategy. We need to identify the necessary conditions to use
type reductions and ensure type soundness.
\begin{figure}[ht]
  \small
  \begin{tabularx}\textwidth{X X X} 
\begin{code}^^J
type family Tricky a where^^J
\ \ Tricky Bool = Int -> Int^^J
\ \ Tricky a    = Bool^^J
\end{code}&
\begin{code}^^J
funTrick :: a -> Tricky a^^J
funTrick _ = True^^J
\end{code}&
\begin{code}^^J
$\text{\faBomb}$ :: Int^^J 
$\text{\faBomb}$ = funTrick True 5^^J
\end{code}
\end{tabularx}
  \caption{Inconsistency due to Tricky Type Family}
  \label{fig:closed-tf-tricky}
\end{figure}

Fortunately, due to abstract rewriting systems literature\cite{bezem_term_2003},
having a confluent type reduction relation is no only a necessary but also a sufficient condition
to achieve type soundness. If a type has multiple ways of reducing,
it should not matter what way we choose, the final type is obtained is always the same. %apologies to robert frost.
In the above example, we did see a consequence of non-confluence; one way of reduction
gave us !Int -> Int! while the the other, gave us !Bool! resulting in a runtime crash.
We fix this behavior by incorporating flattening and apartness into the type reduction criteron.
%% Motivate type flattening for matching
First we fix our notion of matching:
\begin{defn}[Matching]\label{def:ctf-match}
  We say a type $\tau$ matches $\sigma$ if there is a substitution $\Subst$ such that $\Subst\tau \teq \sigma$ with
  $\dom\Subst \subseteq \TV\tau$.
\end{defn}
We use $\tau_1 \teq \tau_2$ to remind us that $\tau_1$ and $\tau_2$ are equal in the sense
of propositional equality, rather than definitional equality; the latter implies the former.
\begin{defn}[Type Flattening]\label{def:ctf-flatten}
  We say a type $\tau$ is flattened to $\tau_1$, or $\tau_1 = \flatten{\tau}$, when, every
  type family application of the from $\FamCtrs(\many\sigma)$ in $\tau$,
  if $\sigma$ of the form $\FamCtrs'(\many\sigma')$ it is replaced by a type variable,
  such that in the flattened type, every syntactically equivalent type family application
  in $\tau$ is replaced by same type fresh type variable
  and syntactically different type family applications in $\tau$ are replaced by distinct fresh type variables.
\end{defn}
\begin{defn}[Apartness]\label{def:ctf-apart}
  For an equation, say $p$, and a type, say $\tau$, $p$ is apart from $\tau$, if 
  or we cannot find a most general unifier that unifies both the left hand side of the equation
  and the flattened type of $\tau$, or $\mgu{\lhs p}{\flatten\tau}$ fails.
\end{defn}
Finally, the equation selection criterion for type reduction can be defined follows:
\begin{defn}[\CLTF Type Reduction Criteron]\label{def:ctf-simpl-1}
  An equation, say $p$, given in the type family declaration can be used to simplify the type
  $\FamCtrs(\many\tau)$, if the following two conditions hold:
  \begin{enumerate}
  \item The left hand side of the equation, $\lhs p$  matches the the type $\FamCtrs(\many\tau)$
    or $\match{\lhs p}{\FamCtrs(\many\tau)}$.
  \item All equations, $q$, preceding $p$, are apart from $\FamCtrs(\many\tau)$, or
    $\apart {q} {\FamCtrs(\many\tau)}$.
  \end{enumerate}
\end{defn}
Let us reconsider the type !a -> Tricky a!, with the above definition of type familiy reduction.
Now, !Tricky Bool! does not match !Tricky a!, as there is no substitution,
$\Subst$, such that $\Subst\texttt{Bool} \teq \texttt{Int}$.
However, !Tricky Bool! is not apart from !Tricky d!---the substitution $[d\mapsto\texttt{Bool}]$ does unify them,
hence we cannot use the second equation for type reduction; the second criteron from \pref{def:ctf-simpl-1}
is not satisfied.
\begin{figure}[ht]
  \centering\small
  \begin{tabularx}\textwidth{X X X}
\begin{code}^^J
type family G a b where^^J
\ \ G Int Bool = Int^^J
\ \ G a   a    = Bool^^J
\end{code}&
\begin{code}^^J
type family F a where^^J
\ \ F Int    = Char^^J
\ \ F a      = Bool^^J
\end{code}&
\begin{code}^^J
G (F a) (F a)\ $\mathrel{\rightsquigarrow}$ Bool^^J
G (F a) (F b)\ $\mathrel{\not\rightsquigarrow}$ Bool^^J
\end{code}
  \end{tabularx}
  \caption{Type family Reduction Example}
  \label{fig:ctf-red-ex}
\end{figure}

Type flattening with sharing is necessary in apartness check to ensure type soundness.
For example, consider the type families shown in \pref{fig:ctf-red-ex},
if we have a type !G (F a) (F a)!, flattening the type would give us !G c c!,
and we will be able to match it with the second equation !G a a! and it will
be apart from !G Int Bool!. However, after flattening the type !G (F a) (F b)!,
becomes !G c d! and it is not apart from !G Int Bool!.

Simplification of type families by using apartness criterion will ensure consistency
but it has two shortcomings: 1) it is overly restrictive, and 2) it is inefficient due to the excessive calls to unification.
We will illustrate them by using a couple examples: Consider second and third equations from !Add! type family---
!Add a Float = Float! and !Add Float a = Float!---, and the type !Add Float b!, which we wish to reduce.
In this case, reduction of !Add Float b! to !Float! is not possible as the second equation is not apart
from !Add Float b!. But we know that both the equations reduce to the same final type, which is !Float!.
We call such equations conincident equations. We would like to allow such reductions as they will not
threaten consistency. Next, consider the equations of the !G a b! type family, !G Int Bool! and !G a a!.
It is easy to see that if any type matches !G a a! it will always be apart from !G Int Bool!, and
we can thus skip on the apartness check in such cases.

We can overcome on both the described shortcomings by using the notion of compatibility of equations defined below in
our reduction criteron.
\begin{defn}[Compatible Equations]\label{def:compact-eqns}
  Two equations, $p$ and $q$, are compatible   if and only if there exist two substitutions,
  say $\Subst_1$ and $\Subst_2$, such that if their application to the left hand sides of the equations
  equates them then the right hand sides after applying the respective substitutions also equates them.
  More succinctly, $\compat p q$ iff there exist substitutions $\Subst_1$ and $\Subst_2 $
  such that if $\Subst_1(\lhs{p}) = \Subst_2(\lhs{q})$ then $\Subst_1(\rhs{p}) = \Subst_2(\rhs{q})$.
\end{defn}
\begin{defn}[\CLTF Type Reduction Criteron Optimized]\label{def:ctf-simpl}
  An equation, say $p$, given in the type family declaration can be used to simplify the type
  $\FamCtrs(\many\tau)$, if the following two conditions hold:
  \begin{enumerate}
  \item The left hand side of the equation, $\lhs p$  matches the the type $\FamCtrs(\many\tau)$,
    or $\match{\lhs p}{\FamCtrs(\many\tau)}$.
  \item All equations, $q$, preceding $p$, are either apart from $\FamCtrs(\many\tau)$, or
    the equations are compatible. Symbolically, $\compat p q \lor \apart {\lhs q} {\FamCtrs(\many\tau)}$
  \end{enumerate}
\end{defn}
The two key insights here are that compatibility check loosens up the restriction
to enable type reductions without threatening soundness, and compatibility of equations
can be precomputed as it does not depend on the type we want to reduce
thus, effectively giving us a cheaper check as compared to the apartness check.

\subsection{Formalizing Type Reduction and Type Soundness}\label{subsec:tf-closed-formal}
\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      &\text{Type family Constructors} & \FamCtrs,\MoreFamCtrs\\
      &\text{Type Constants} &\texttt{\TypeCtrs}\\
      \\
      % &\text{Type Validity}               &\ValidType \TEnv \tau\\
      % &\text{Proposition Validity}        &\ValidProp \TEnv \pi\\
      % &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      % &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      % &\text{Context Validity}            &\ValidCtx\TEnv\\
      \\
      &\text{Type reduction}              &\tystepsto\GEnv\bullet\bullet
      % \\
      % &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      % &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      \\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau %\bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs\\% 
      &\text{Value Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \TypeCtrs\\
      &\text{Type Equality Predicate}      &\pi          &\bnfeq \tau\teq\tau\\
      &\text{Predicates}     &\Preds       &\bnfeq \many\pi\\
      &\text{Type family Pattern}     &\texttt{\FamPattern} &\bnfeq \many\tau\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      % &\text{Coercions}  &\Co,\MoreCo &\bnfeq \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
      %                                   \bnfor \FamCtrs(\many{\Co}) \bnfor\TypeCtrs(\many{\Co})\\
      % &                  &            &\bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
      %                                   \bnfor \branch{i}{\many\tau} & \\
      % \\
      % &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
      %                                   \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau  \\
      % &                  &            & \bnfor \DataCtrs\many{e} \\
      % &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm\\
      \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom:\AxiomTy
                                        %\bnfor \GEnv,\FamCtrs:n\\% \bnfor \GEnv,\TypeCtrs:n\\
      % &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,x\co\tau \bnfor \VEnv,\alpha\\
      % &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
      % \\
      % &\text{Type family Declaration} & & \texttt{\textbf{type family}}~
      %                                     \FamCtrs\App\many{\alpha}\texttt{\textbf{ where }}
      %                                     \many{F\App\FamPattern = \tau}
    \end{array}
  \]
  \caption[Excerpt \CLTF{}]{Excerpt of System for Closed Type Families (\CLTF)}
  \label{fig:syntax-tf-closed}
\end{figure}
In the previous section, we alluded that type soundness can be achieved using
confluence. In this section we will formalize it using \CLTF. The portion of the system necessary
to show type soundness is shown in \pref{fig:syntax-tf-closed}. We have special syntax category for
type family consructors ($\FamCtrs,\MoreFamCtrs$) along with the usual types.
A type pattern ($\FamPattern$) are tuple of types none of which contain type family constructors.
The size of the pattern is same as that of the type family constructor arity.
Predicates in this system are type equalites $\tau_1\teq \tau_2$ that asserts types $\tau_1$ and $\tau_2$ are equal.
The axioms, ($\Axiom\co\AxiomTy$), are named list of type family equations that are declared
with the type family constructors. For example, the type family declaration for !TEq a b! will
be represented in our system as
$\texttt{AxTEq}: [\forall\alpha.~{\texttt{TEq}~\alpha~\alpha} \teq \texttt{TT}
, \forall\alpha\beta.~{\texttt{TEq}~\alpha~\beta} \teq \texttt{FF}]$,
and the !Plus m n! type family will be represented as
$\texttt{AxPlus}: [\forall\alpha.~{\texttt{Plus}~Z~\alpha} \teq \texttt{Z}
, \forall\alpha\beta.~{\texttt{Plus}~(\texttt{S}~\alpha)~\beta} \teq \texttt{S}(\texttt{Plus}~\alpha~\beta)]$
We refer the collection of axioms along with the family constructors as the ground context ($\GEnv$).

We can now formally state type reduction as follows:
\begin{defn}[Type Reduction: $\tystepsto\GEnv\bullet\bullet$, $\manytystepsto\GEnv\bullet\bullet$]\label{def:type-reduction}
  A type $\tau$ reduces to type $\sigma$, written $\tystepsto\GEnv{\tau}{\sigma}$,
  if we can build a non-empty sequence of predicates $\Preds$ using the axioms in $\GEnv$ such that,
  the first predicate is of the form $\tau\teq\tau_i$ and the last predicate
  of the sequence is of the from $\tau_j\teq\sigma$. $\manytystepsto\GEnv\bullet\bullet$ is a reflexive and transitive closure of $\tystepsto\GEnv\bullet\bullet$.
\end{defn}
We are essentially giving semantics to type reduction using a sequence of predicates.
The typechecker has two main ways to generate
equality predicates. It can either find an appropriate axiom to instantniate from the ground context,
or it can use one of the following axioms: reflexivity ($\empt\entails\tau_1\teq\tau_1$),
symmetry ($\tau_1\teq\tau_2 \entails \tau_2\teq\tau_1$),
transitivity ($\tau_1\teq\tau_2, \tau_2\teq\tau_3\entails\tau_1\teq\tau_3$),
and congruence ($\tau_{11}\teq\tau_{21},\tau_{21}\teq\tau_{22} \entails(\tau_{11}\to\tau_{21})\teq(\tau_{12}\to\tau_{22})$).
These extra axioms are due to the fact that type equality forms an equivalence relation and a congruence relation.
The appropriateness of axioms is exactly what \pref{def:ctf-simpl} describes. We formalize the definition
in a rule format as shown in \pref{fig:tf-closed-nc}. Finally, the rule \trule{ty-$\beta$}
packages everything together. This rule says that the $i$-th equation of axiom $\Axiom$,
$\Forall{\many\alpha}{\FamCtrs(\FamPattern_i) \teq \sigma_i}$, is used to reduce
the target type $\FamCtrs(\many\tau)$ to type $\tau_0$.
The clause $\forall j < i. ~\nc \AxiomTy i {\many\tau} j$ ensures that we do not
perform unsound reductions. The $\TEvalCtxt\bullet$ says that the type reduction
can occur anywhere within the type structure. 

\newcommand\NcApart{
  \ib{\irule[\trule{nc-apart}]
    {\AxiomTy = \many{\FamCtrs(\FamPattern) \teq \sigma}}
    {\apart{\FamPattern_j}{\FamPattern_i[\many\tau/\many\alpha_i]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\NcCompt{
  \ib{\irule[\trule{nc-compt}]
    {\compat {\AxiomTy[i]}{\AxiomTy[j]}};
    {\nc \AxiomTy i {\many\tau} j}}
}
\newcommand\CompatInc{
  \ib{\irule[\trule{compt-inc}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\substack{{\Subst = \mgu{\FamPattern_1}{\FamPattern_2}} \\
        {\Subst\sigma_1 = \Subst\sigma_2}}};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}

\newcommand\CompatDist{
  \ib{\irule[\trule{compt-dis}]
    {\substack {\AxiomEq_1 = \FamCtrs(\FamPattern_1) \teq \sigma_1\\
        {\AxiomEq_2 = \FamCtrs(\FamPattern_2) \teq \sigma_2}}}
    {\Subst = \mgu{\FamPattern_1}{\FamPattern_2}\fails};
    {\compat{\AxiomEq_1}{\AxiomEq_2}}}
}

\newcommand\TypeRed{
  \ib{\irule[\trule{ty-$\beta$}]
    {\substack{{\AxiomTy = \many{\Forall{\many\alpha}\FamCtrs(\FamPattern) \teq \sigma}}\\{\Axiom\co\AxiomTy\in\GEnv}}}
    {\forall j < i. ~\nc \AxiomTy i {\many\tau} j}
    {\substack{\Subst=\mgu {N_i}{\many\tau}\\\tau_0 = \Subst\sigma_i}};
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_0}}} }
}

\begin{figure}[ht]
  \small
  \[
    \begin{array}{c c}
      \NcApart & \CompatDist\\
      \NcCompt & \CompatInc
    \end{array}
  \]
  \[
    \begin{array}{c}
      \TypeRed
    \end{array}
  \]  
  \caption{Non Conflicting Equations, Compatibility and Type Reduction}
  \label{fig:tf-closed-nc}
\end{figure}

To get an idea of how these rules work out for the type reduction, let us consider the type !TEq Z (Plus (S a) b)!,
along with the axioms \texttt{AxTEq} and \texttt{AxPlus}. First, we see that !Plus (S a) b! $\steps$ !S (Plus a b)!,
as $\texttt{AxPlus}[1]$ is not in conflict with $\texttt{AxPlus}[2]$,
they are compatible due to disjointnes by rule \trule{compat-dis},
and $\texttt{AxPlus}[2]$ matches !Plus (S a) b! with the substitution
$[\alpha\mapsto\texttt{a}, \beta\mapsto\texttt{b}]$.
Thus, !TEq Z (Plus (S a) b)$\steps$TEq Z (S (Plus a b))!.
Now, $\texttt{AxTEq}[2]$ can be used for the following reduction:
!TEq Z (S (Plus a b)) $\steps$ FF!, as $\texttt{AxTEq}[1]$ does not conflict $\texttt{AxTEq}[2]$
and $\texttt{AxTEq}[2]$ with the substitution $[\alpha\mapsto Z,\beta\mapsto\texttt{S (Plus a b)}]$
matches !TEq Z (S (Plus a b))!. The predicates that we built in this process were:
!Plus (S a) b! $\teq$ !S (Plus a b)!, !TEq Z (Plus (S a) b)! $\teq$ !TEq Z (S (Plus a b))!.

\newcommand\TCast{
  \ib{\irule[\trule{t-cast}]
    {\CoTyping \TEnv \Co {\tau_1\teq\tau_2}}
    {\Typing \TEnv \Tm \tau_1};
    {\Typing \TEnv \Tm \tau_2}}}

\newcommand\TTyAbs{
  \ib{\irule[\trule{t-tyabs}]
    {\ValidType \TEnv \alpha}
    {\Typing {\TEnv,\alpha} \Tm \tau};
    {\Typing \TEnv {\TLam\alpha\Tm} {\Forall\alpha\tau}}}}

\newcommand\TTyApp{
  \ib{\irule[\trule{t-tyapp}]
    {\ValidType \TEnv {\tau_1}}
    {\Typing \TEnv \Tm {\Forall\alpha\tau}};
    {\Typing \TEnv {\Tm\App\tau_1} \tau[\tau_1/\alpha]}}}


\newcommand\CoArr{
  \ib{\irule[\trule{co-arr}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \sigma_1}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \sigma_2}};
    {\CoTyping \TEnv {\Co\to\MoreCo} {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}}}}

\newcommand\CoNthArr{
  \ib{\irule[\trule{co-ntharr$_i$}]
    {\CoTyping \TEnv \Co {(\tau_1\to\tau_2) \teq (\sigma_1\to\sigma_2)}};
    {\CoTyping \TEnv {\nth i \Co} {\tau_i \teq \sigma_i}}}}

\newcommand\CoForall{
  \ib{\irule[\trule{co-forall}]
    {\CoTyping {\TEnv,\alpha} \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\Forall\alpha\Co} {(\Forall\alpha\tau_1) \teq (\Forall\alpha\tau_2)}}}}

\newcommand\CoInst{
  \ib{\irule[\trule{co-inst}]
    {\ValidType\TEnv\tau}
    {\CoTyping {\TEnv} \Co {\Forall\alpha\sigma_1 \teq \Forall\alpha\sigma_2}};
    {\CoTyping \TEnv {\Co@\tau} {\sigma_1[\alpha/\tau] \teq \sigma_2[\alpha/\tau]}}}}
   
\newcommand\CoRefl{
  \ib{\irule[\trule{co-refl}]
    {\ValidType\TEnv\tau};
    {\CoTyping \TEnv {\refl{\tau}}:\tau\teq\tau}}}

\newcommand\CoSym{
  \ib{\irule[\trule{co-sym}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}};
    {\CoTyping \TEnv {\sym{\Co}} {\tau_2\teq\tau_1}}}}

\newcommand\CoTrans{
  \ib{\irule[\trule{co-trans}]
    {\CoTyping \TEnv \Co {\tau_1 \teq \tau_2}}
    {\CoTyping \TEnv \MoreCo {\tau_2 \teq \tau_3}};
    {\CoTyping \TEnv {\comp \Co \MoreCo} \tau_1\teq\tau_3}}}

\newcommand\CoNth{
  \ib{\irule[\trule{co-nth}]
    {\CoTyping \TEnv \Co {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}};
    {\CoTyping \TEnv {\nth i {\Co}} {\tau_i\teq\sigma_i}}}}

\newcommand\CoTypeCtr{
  \ib{\irule[\trule{co-type}]
    {\TypeCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\TypeCtrs\many\Co} {\TypeCtrs\many\tau \teq \TypeCtrs\many\sigma}}}}

\newcommand\CoFam{
  \ib{\irule[\trule{co-fam}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\CoTyping {\GEnv;\VEnv} {\Co_i} {\tau_i \teq \sigma_i}}^{i<n}};
    {\CoTyping {\GEnv;\VEnv} {\FamCtrs\many\Co} {\FamCtrs\many\tau \teq \FamCtrs\many\sigma}}}}

\newcommand\CoAxiom{
  \ib{\irule[\trule{co-axiom}]
    {\substack {\AxiomTy = \many{\Forall{\many\alpha}{\FamCtrs(\FamPattern) \teq \sigma}}\\
               \Axiom\co\AxiomTy \in \GEnv}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\ValidCtx{\GEnv;\VEnv}};
    {\CoTyping {\GEnv;\VEnv} {\branch i {\many\tau}} {\FamCtrs (\FamPattern\many{[\alpha_i/\tau_i]}) \teq \sigma\many{[\alpha_i/\tau_i]}}}}}

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%     \TCast   % & \TTyAbs & \TTyApp
%     \end{array}
%   \]
%   \[  
%     \begin{array}{c c c}
%       \CoRefl & \CoSym & \CoTrans
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%       \CoArr     & \CoNthArr\\      
%       \CoTypeCtr & \CoNth\\
%       \CoForall  & \CoInst\\
%       \CoFam     & \CoAxiom
%     \end{array}
%   \]
%   \caption[Typing Judgments for \CLTF{}]{Typing Judgments \CLTF{}}
%   \label{fig:tf-closed-typing}
% \end{figure}
The above exercise also illuminates an important property of \CLTF:
if we have a type reduction from $\tau_1$ to $\tau_2$ then we can build a type predicate $\tau_1\teq\tau_2$.
We abuse the notation for entailment, $\GEnv\entails\tau_1\teq\tau_2$, to mean we can obtain the
type equality predicate $\tau_1\teq\tau_2$ by using all necessary instantiations of the axioms in $\GEnv$.
\begin{lemma}[Completeness of Type reduction]
  if $\manytystepsto\GEnv{\tau_1}{\tau_2}$ then $\GEnv\entails\tau_1\teq\tau_2$ 
\end{lemma}

%\subsubsection{Consistency and Goodness of Context}\label{subsec:tf-closed-consistency}
Consistency means we can never derive unsound equalities between value types,
such as $\texttt{Int}\teq\texttt{Bool}$, in the system. Value types ($\GTy$), in \CLTF are
type constants, $\TypeCtrs$, and function types $\tau_1\to\tau_2$.
Consistency of the type system hinges on the fact that we have a consistent context.
We say that a ground context $\GEnv$ is consistent, when for all predicates $\GTy_1 \teq \GTy_2$,
which we can build from $\GEnv$, or $\GEnv\entails\GTy_1\teq\GTy_2$, the two following properties holds:
\begin{enumerate}
\item if $\GTy_1$ is $\TypeCtrs$ then, $\GTy_2$ is also $\TypeCtrs$
\item if $\GTy_1$ is $\tau_1\to\tau_2$ then, $\GTy_2$ is also $\tau_1\to\tau_2$.
\end{enumerate}

\begin{lemma}[Type soundness]
  If $\GEnv$ is consistent then, \CLTF is type sound.
\end{lemma}
In general, consistency is difficult to prove. We will instead take a conservative approach
and enforce syntactic restrictions on the ground context.
\begin{defn}[$\Good~\GEnv$]\label{def:good-ctx}
  A ground context ($\GEnv$) is good, written $\Good\GEnv$ when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  where $\AxiomTy$ is of the form $\many{\Forall{\many\alpha}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$,
    and none of the type pattern $\FamPattern_i$ mentions a type family constructor.
  \item The binding variables $\many\alpha$ occur at least once in the type pattern $\FamPattern$,
    on the left hand side of the equation.
  \end{enumerate}
\end{defn}
Given our characterization of type reduction in the previous section, we now have to show
that if we have $\Good\GEnv$ then, $\GEnv$ is consistent. One way to prove this is
via confluence of the type reduction relation. Type reduction relation given by the rule $\trule{ty-red}$
works only on type families and does not reduce any value types; making 
confluence a sufficient condition to ensure consistency. To prove confluence, we first prove that the
rewrite relation has local confluence---whenever we have ${\tau_1}\teq{\tau_2}$, then 
then we can always find a common reduct type $\tau_3$ such that $\manytystepsto \GEnv {\tau_1} {\tau_3}$ and
$\manytystepsto \GEnv {\tau_2} {\tau_3}$---and finally, appeal to Newman's lemma\cite{newman_theories_1942} given below
to prove type reduction is confluent.
\begin{lemma}[Newman]
  If a rewrite system is terminating and locally confluent, then it is confluent.
\end{lemma}
The design of \CLTF does leave the door open for non-terminating type family definitions and 
we have to make do with a weaker consistency lemma than what we originally hoped for.
\begin{lemma}[$\GEnv$ Consistency]
  If $\tystepsto \GEnv \bullet \bullet$ is terminating, and $\Good\GEnv$ then, $\GEnv$ is consistent.
\end{lemma}

% \subsection{Type safety of \CLTF{}}\label{subsec:tf-closed-safety}
\newcommand\SApp{
  \ib{\irule[\trule{s-app}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Tm_2} {\Tm'_1\App\Tm_2}}}
}
\newcommand\STApp{
  \ib{\irule[\trule{s-tapp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\tau} {\Tm'_1\App\tau}}}
}

\newcommand\SCApp{
  \ib{\irule[\trule{s-capp}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\Tm_1\App\Co} {\Tm'_1\App\Co}}}
}

\newcommand\SCast{
  \ib{\irule[\trule{s-cast}]
    {\stepsto {\Tm_1} {\Tm'_1}};
    {\stepsto {\cast{\Tm_1}\Co} {\cast{\Tm'_1}\Co}}}
}

\newcommand\SBeta{
  \ib{\irule[\trule{s-$\beta$}];
    {\stepsto {(\Lam x \tau \Tm_1)\App\Tm_2} {\Tm_1[x/\Tm_2]}}
  }
}
\newcommand\STBeta{
  \ib{\irule[\trule{s-T$\beta$}];
    {\stepsto {(\TLam \alpha \Tm)\App\tau} {\Tm[\alpha/\tau]}}
  }
}

\newcommand\SPush{
  \ib{\irule[\trule{s-push}]
    {\Co_1 = \sym{\nth 0 \Co}}
    {\Co_2 = \nth 1 \Co};
    {\stepsto {(\cast {\Lam x \tau \Tm} \Co) \App \Tm_1} {\cast {(\Lam x \tau \Tm)\App(\cast{\Tm_1} {\Co_1})} {\Co_2}}}
  }
}
\newcommand\STPush{
  \ib{\irule[\trule{s-tpush}];
    {\stepsto {(\cast {\TLam \alpha \Tm} \Co) \App \tau} {\cast {(\TLam \alpha \Tm)\App\tau} {\Co@\tau}}}
  }
}
\newcommand\STrans{
  \ib{\irule[\trule{s-trans}];
    {\stepsto {\cast {(\cast \Tm \Co)} \MoreCo} {\cast \Tm {\comp\Co\MoreCo}}}
  }
  
}

\section{Constrained Type families}\label{sec:tf-constrained}
In the previous section for closed type families, we made an implicit assumption
that all type families are total, in the sense their domain is all the types.
This has philosophical and practical consequences.
Consider the example as shown in \pref{fig:partial-tyfam}.

\begin{figure}[ht]
    \footnotesize
  \begin{tabularx}\textwidth{X X}
\begin{code}^^J
type family PTyFam a where^^J
\ \  PTyFam Int = Bool^^J
^^J
type family Loop a where^^J
\ \  Loop a = [Loop a]^^J
\end{code}&%
\begin{code}^^J
g x = x : x -- Error^^J
^^J
TEq [a] a \ $\steps$\ $???$^^J
\end{code}
  \end{tabularx}
  \caption{Partial Closed Type Family}
  \label{fig:partial-tyfam}
\end{figure}
We know that !PTyFam Bool! has no satisfying equations associated with it
that gives it a meaning and never will in the future
as it is closed. So, is !PTyFam Bool! a type? 
The implimentation of \CLTF in GHC\cite{ghc_2020}, a compiler for Haskell,
it is treated as a type. This has practical consequences. Consider the type !TEq [a] a!.
Our intuition is to reduce !TEq [a] a! to !FF! as we can never have a list type, ![a]!,
equal to its element type, !a!.
Given our type reduction criterion described in \pref{def:ctf-simpl},
the first equation does not match !TEq [a] a! and the second equation does.
However, we cannot assert that !TEq [a] a! is apart from !TEq a b!. 
The reason being that there might exist a type family !Loop a! that reduces to ![Loop a]!.
Thus, !TEq [Loop Bool] (Loop Bool)! can reduce to !TEq [Loop Bool] [Loop Bool]!, and eventually rewrite to !TT!.
Hence, GHC does not reduce !TEq [a] a! to !FF!; it uses an apartness check based on unification for
infinite types rather than Robinson's unification.
But GHC also not support infinite types; a declaration such as,
!g x = x : x!, does not typecheck as !g! is of type !$\forall$ a. ([a] ~ a) => a -> a!;
but the infinite type !Loop a! is accepted by GHC. We are left in a confusing situation
where we accept some problematic types, like !Loop a!, but not all like ![a] ~ a => a!.

The nub of the issue is that there is a mismatch in our intuitive semantics of type families.
We think of them as partial functions on types where each new equation extends its definition.
Instead we should be thinking of them as introducing a family of distinct types and
each new equation equates types that were previously not equal.
One possible solution to this conundrum is to reject the definition of infinite type families
like !Loop a! but this burdens the programmers by enforcing them to provide an evidence
to guarantee termination. We defer going in that direction.
Instead, to solve this problem we leverage the existing infrastructure that Haskell already has---qualified
types---to make the totality assumption explicit using constrained type families (\QLTF).


% \subsection{Closed Typeclasses}
% Typeclasses can be extended to have new instances. Closed typeclasses, on the contrary,
% are classes that cannot be extended once they are defined. They mirror closed type families
% in the same way as no more equations can be added once a closed type family is defined.
% Instances for a closed typeclass and their resolution
% will be performed at operator's use site in a top to bottom order on instance declarations.

% For example, the type families !TEq a b! and !Plus m n! can be expressed
% in the closed typeclass world using !TEqC a b! and !PlusC m n! respectively as shown in \pref{fig:closed-tc-examples}.
% \begin{figure}[ht]
%     \footnotesize
%   \begin{tabularx}\textwidth{X X}
% \begin{code}^^J
% class LoopC where^^J
% \ \ type Loop^^J
% \ \ instance LoopC => LoopC where^^J
% \ \ \ \  type Loop = [Loop]^^J
% \end{code}&%
% \begin{code}^^J
% class PTyFamC a where^^J
% \ \ type PTyFam a^^J
% \ \ instance PTyFamC Int where^^J
% \ \ \ \ type PTyFam Int = Bool^^J
% \end{code}\\    
% \begin{code}^^J
% class \{-TOTAL-\} TEqC a b where^^J
% \ \ type TEq a b^^J
% \ \ instance TEqC a a where^^J
% \ \ \ \  type TEq a a = TT^^J
% \ \ instance TEqC a b where^^J
% \ \ \ \ type TEq a b = FF^^J
% \end{code}&%
% \begin{code}^^J
% class \{-TOTAL-\} PlusC m n where^^J
% \ \ type Plus m n^^J
% \ \ instance PlusC Z m where^^J
% \ \ \ \  type Plus Z m = Z^^J
% \ \ instance PlusC m n => PlusC (S m) n where^^J
% \ \ \ \  type Plus (S m) n = S (Plus m n)^^J
% \end{code}
%   \end{tabularx}
%   \caption{Closed Typeclasses Examples}
%   \label{fig:closed-tc-examples}
% \end{figure}
% In the constrained type families world, every closed type family will be associated with
% a closed typeclass. Any type family without an associated typeclass will be disallowed.
% For example, see !class PTyFamC!. The type for !sillyFst! in this system is no longer
% !$\forall$ a. a -> a! but instead it is !$\forall$ a. PTyFamC Bool => a -> a!, and the type
% checker will flag it as an error wherever it is used; there is no way to satisfy
% the instance !PTyFamC Bool!. The type family !Loop! will also need to have
% an associated typeclass !LoopC!. To declare an instance of !LoopC!
% where !Loop ~ [Loop]! we need to specify !LoopC! to be a constraint on the instance.
% This makes the use of !Loop! no longer threatens the type soundness as !LoopC! is unsatisfiable.

% Most type families are partial, only some are total and we would want
% the users to take advantage of this fact by allowing programmers to explicitly state totality.
% In general, checking for or inferring totality for a given closed type family is a hard problem,
% thus we would also give the users a way to let the type checker accept it without checking it.
% It would enhance usability of the system to express total type families. 

\subsection{Type matching and Apartness Simplified}
The type rewriting in closed type families had a complex criterion for apartness that included
flattening and then checking if they had a unifier using infinitary unification.
In constrained type families we neither have to depend on infinitary type unification nor flattening of types. 
% The constraint of allowing only terminating
% type families can also be lifted it no longer threaten type soundness. 
Apartness in this system is just checking for failure of unification using
Robinson's algorithm.

\begin{defn}[\QLTF Type Reduction Criteron]\label{def:ctf-simpl-1}
  An equation, say $p$, given in the type family declaration can be used to simplify the type
  $\FamCtrs(\many\tau)$, if the following two conditions hold:
  \begin{enumerate}
  \item The left hand side of the equation, $\lhs p$  matches the the type $\FamCtrs(\many\tau)$
    or $\match{\lhs p}{\FamCtrs(\many\tau)}$.
  \item All equations, $q$, preceding $p$, do not match $\FamCtrs(\many\tau)$ or
    they are compatible, or $\compat p q \lor \lnot\mgu{\lhs p}{F(\many\tau)}$.
  \end{enumerate}
\end{defn}

\subsection{Formalizing Type reduction and Type Soundness}\label{subsec:tf-constrained-formal}

\begin{figure}[ht]
    \footnotesize
  \[
    \begin{array}{l l l}
      &\text{Type family Constructors} &\FamCtrs,\MoreFamCtrs\\
      &\text{Type Constants} &\texttt{\TypeCtrs}\\      
      % \\
      % &\text{Type Validity}               &\ValidType \TEnv \tau\\
      % &\text{Proposition Validity}        &\ValidProp \TEnv \Preds\\
      % &\text{Assumption Validity}      &\ValidAssmp \TEnv {\many\chi}\\
      % &\text{Ground Context Validity}     &\ValidGCtx{\GEnv}\\
      % &\text{Variable Context Validity}   &\ValidVCtx\GEnv\VEnv\\
      % &\text{Context Validity}            &\ValidCtx\TEnv\\
      % \\
      % &\text{Term Typing}              &\Typing \TEnv \Tm \tau\\
      % &\text{Coercion Typing}          &\CoTyping \TEnv \Co \Preds\\
      % &\text{Resolution Validity}      &\ResTyping \TEnv {\many q} {\many\chi}\\
      \\
      &\text{Type reduction}              &\tystepsto\GEnv\bullet\bullet\\
      &\text{One Hole Type Context}    &\TEvalCtxt{\bullet}
    \end{array}
    \begin{array}{l l l l l}
      &\text{Types}           &\tau,\sigma  &\bnfeq \alpha \bnfor \tau\to\tau %\bnfor \Forall\alpha\tau
                                              \bnfor \FamCtrs(\many\tau) \bnfor \TypeCtrs
                                              \bnfor \text{\shaded{$\Preds\then\tau$}}&\\
      &\text{Value Types}    &\GTy         &\bnfeq \tau\to\tau \bnfor \TypeCtrs\\
      &\text{Type Equality Predicate}      &\pi       &\bnfeq \tau\teq\tau\\
      &\text{Predicates}                   &\Preds    &\bnfeq \many\pi\\
      &\text{Axiom Equations} &\AxiomEq     &\bnfeq \text{\shaded{$\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau)
                                              \teq \sigma$}}}\\
      &\text{Axiom Types}     &\AxiomTy     &\bnfeq \many\AxiomEq\\
      % &\text{Coercions}  &\Co,\MoreCo &\bnfeq c \bnfor \Co\to\MoreCo \bnfor \Forall\alpha\Co \bnfor \Co@\tau
      %                                   \bnfor \FamCtrs(\many{\Co}) \bnfor \TypeCtrs(\many{\Co})\\
      % &                  &            & \bnfor \nth i \Co \bnfor \refl\tau \bnfor \sym{\Co} \bnfor \comp\Co\MoreCo
      %                                   \bnfor \text{\shaded{$\Co_1\teq\Co_2\then\MoreCo$}}
                                        % \bnfor \text{\shaded{$\qbranch{i}{\many\tau}{\many q}$}} & \\
      &\text{Eval Assumption}   &\chi &\bnfeq \text{\shaded{$(\alpha|c : \FamCtrs(\many\tau) \teq \alpha)$}} \\
      &\text{Eval Resolution}   &q    &\bnfeq \text{\shaded{$(\tau|\Co)$}}\\      
      \\
      % &\text{Terms}      & \Tm        &\bnfeq x \bnfor \Lam x \tau \Tm \bnfor \Tm\App\Tm \bnfor\cast M \Co 
      %                                   \bnfor \TLam \alpha \Tm \bnfor \Tm\App\tau \bnfor\DataCtrs\many{e} \\
      % &                  &            & \bnfor \text{\shaded{$\Lam c \Preds \Tm$}} \bnfor \text{\shaded{$\Tm\App \Co$}}
      %                                   \bnfor \text{\shaded{$\tassume\chi\Tm$}} \\
      % &\text{Values}     &\Val        &\bnfeq \Lam x \tau \Tm \bnfor \DataCtrs\many\Tm \bnfor \TLam \alpha \Tm \bnfor
      %                                   \text{\shaded{$\Lam c \Preds \Tm$}}\\
      % \\
      &\text{Ground Context} &\GEnv   &\bnfeq \empt \bnfor \GEnv,\Axiom\co\AxiomTy
                                        % \bnfor \text{\shaded{$\GEnv,\FamCtrs\co_\top n$}} \bnfor \GEnv,\FamCtrs\co n
                                        % \bnfor \GEnv,\TypeCtrs \co n\\
      % &\text{Variable Context}&\VEnv  &\bnfeq \empt \bnfor \VEnv,\alpha \bnfor \VEnv,x\co\tau
      %                                   \bnfor \text{\shaded{$\VEnv,c\co\Preds$}}\\
      % &\text{Typing Context}  &\TEnv  &\bnfeq \GEnv;\VEnv\\
    \end{array}
  \]
  \caption[\QLTF]{Excerpt of \QLTF}
  \label{fig:tf-constrained-system}
\end{figure}

\QLTF is similar to \CLTF except for a few new constructs that
we highlight in \pref{fig:tf-constrained-system}. The type can be qualified with a predicate ($\Preds\then\tau$)
and the predicates are nothing but type equalities, of the form $\tau\teq\tau$ as before.
Each type equality equation is of the form $\Forall {\many\alpha~\many\chi}{\FamCtrs(\many\tau)\teq\sigma}$
where both $\many\tau$ and $\sigma$ do not have occurrence of any family type constructors. 
The equations are quantified not only by the type variables $\many\alpha$
but also over evaluation assumptions $\many\chi$.
The evaluation assumptions are of the form ($\alpha|c\co\FamCtrs(\many\tau)\teq\alpha$) and read as
``$\alpha$ such that $c$ witnesses $\FamCtrs(\many\tau)$ reduces to $\alpha$''.
We use these evaluation assumptions to allow type families on the left hand side
of the type equations written in the source program. For example,
the user written type equation  !F (F' a) a b = G a b!, where !G! and !F'! are type family constructors,
will be compiled to an equation such as
$\forall\alpha\beta~(b|c:\texttt{G}~\alpha\beta \teq b)(d|c':\texttt{F}'~\alpha\teq d).~\texttt{F}d~\alpha~\beta
\teq b$.
% Evaluation assumptions are essential to support axioms that mention
% type families on the right hand side of the equations in source.
We use $\chi$ to remind us that it is more specific than $\pi$; for any $\chi$,
the left hand side of the type equality is always a type family and right and side is a fresh variable.
% The $\tassume\chi\Tm$ is the construct that is used while working with total type families.
% It provides a sort of an escape hatch as we are guaranteed to obtain a type family free type
% after reducing a total type family.

The valid types in this system are only those that mention type family constructors in the predicate set $\Preds$.
For example, the type !$\forall$m n. Add m n => m -> n -> Result m n! would instead be written
as !$\forall$m n. Result m n ~ p => m -> n -> p!. This is an assertion that !Result m n! evaluates to a
type family free type.

% The new validity judgments reflect the above discussion. The rule \trule{v-qty} ensures
% that type equality coercions can appear only in $\Preds$. We do not have the rule \trule{v-tfctr}
% in this system to ensure values types do not mention type family constructors.
% The rule \trule{v-qtfp} replaces the rule \trule{v-tfp}. This means that arguments to type family
% constructors can mention type families and we no longer have to use special type patterns as in \CLTF's \trule{v-tfp}.
% The rule \trule{v-qgax} replaces the \trule{v-gax} that checks axiom equations are valid. This checks that the context
% is consistent by making sure it is \Good, as discussed in \pref{subsubsec:tf-constrained-goodness-consistency}.
% We also have two new classes of validity judgments, \trule{v-assmn} and \trule{v-assmc} check
% that the evaluation assumptions that appear in the axioms are valid, while rules \trule{v-rese}
% and \trule{v-resc} ensure that the evaluation resolutions are valid.

\newcommand\ResNil{
  \ib{\irule[\trule{v-rese}]
    {\ValidCtx \TEnv};
    {\ResTyping \TEnv \empt \empt}
  }
}
\newcommand\ResCons{
  \ib{\irule[\trule{v-resc}]
    {\ValidType \TEnv \sigma}
    {\CoTyping \TEnv \Co {\FamCtrs(\many\tau)\teq\sigma}}
    {\ResTyping \TEnv {\many q} {\many\chi[\alpha/\sigma]}};
    {\ResTyping \TEnv {(\sigma|\Co), \many q} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha), \many \chi}}
  }
}

\newcommand\ValidQGndContextAxiom{
  \ib{\irule[\trule{v-qgax}]
    {\substack {\ValidGCtx\GEnv\\
        \fresh \Axiom\GEnv}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i,\TV{\many\chi}} {\tau_{0i}}}}\\
        {\many{\ValidProp{\GEnv;\empt}{\Forall{\many\alpha}{\FamCtrs(\many\tau)\teq\sigma}}}}}}
    {\substack {{\many{\ValidType {\GEnv;\many\alpha_i} {\many\tau_i}}}\\
      {\ValidAssmp {\GEnv;\many\alpha_i} {\many\chi_i}}}}
    {\FamCtrs\co n \in \GEnv};
    {\ValidGCtx{\GEnv,\Axiom\co\many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau_i)\teq\tau_{0i}}}^{i<k}}}
  }
}

\newcommand\ValidNilAssmp{
  \ib{\irule[\trule{v-assmn}];
    {\ValidAssmp \TEnv \empt}}
}

\newcommand\ValidConsAssmp{
  \ib{\irule[\trule{v-assmc}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}^{i<n}}
    {\ValidAssmp {\GEnv;\VEnv,\alpha} {\many\chi}};
    {\ValidAssmp {\GEnv;\VEnv} {(\alpha|c\co\FamCtrs(\many\tau)\teq\alpha),\many\chi}}}
}
\newcommand\ValidQType{
  \ib{\irule[\trule{v-qty}]
    {\ValidProp \TEnv \Preds}
    {\ValidType \TEnv \tau};
    {\ValidType \TEnv {\Preds\then\tau}}}
}
\newcommand\ValidQTyFam{
  \ib{\irule[\trule{v-qtfp}]
    {\FamCtrs\co n \in \GEnv}
    {\many{\ValidType {\GEnv;\TEnv} {\tau_i}}^{i<n}}
    {\ValidType {\GEnv;\VEnv} \sigma};
    {\ValidProp {\GEnv;\VEnv} {\FamCtrs(\many\tau)\teq\sigma}}}
}


\newcommand\ValidQCoVar{
  \ib{\irule[\trule{v-qcovar}]
    {\ValidVCtx\GEnv\VEnv}
    {\ValidProp {\GEnv;\TEnv} \Preds}
    {\fresh c \VEnv};    
    {\ValidVCtx\GEnv{\VEnv,c\co\Preds}}
  }  
}


% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%       \ValidQType & \ValidQTyFam\\
%       \ResNil & \ResCons\\
%       \ValidNilAssmp & \ValidConsAssmp
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c}
%         \ValidQGndContextAxiom &      \ValidQCoVar 
%     \end{array}
%   \]
%   \caption{Validity Judgments for \QLTF}
%   \label{fig:tc-constrained-validity}
% \end{figure}


\newcommand\QCoAbs{
  \ib{\irule[\trule{t-coabs}]
    {\Typing {\TEnv,c\co\Preds} \Tm \tau};
    {\Typing \TEnv {\Lam c \Preds \Tm} {{\Preds\then\tau}}}}}

\newcommand\QCoApp{
  \ib{\irule[\trule{t-coapp}]
    {\Typing \TEnv \Tm {\Preds \then \tau}}
    {\Typing \TEnv \Co {\Preds}};
    {\Typing \TEnv {\Tm\App\Co} \tau}}}

\newcommand\QAssume{
  \ib{\irule[\trule{t-assum}]
    {\many{\ValidType {\GEnv;\VEnv} {\tau_i}}}
    {\FamCtrs\co_\top n \in \GEnv}
    {\Typing {\GEnv;\VEnv,\alpha,c\co\FamCtrs\many\tau\teq\alpha} \Tm {\tau}};
    {\Typing {\GEnv,\VEnv} {\tassume{(\alpha|c\co\FamCtrs\many\tau\teq\alpha)}\Tm} \tau}}}


\newcommand\QCoAxiom{
  \ib{\irule[\trule{co-qaxiom}]
    {\substack {{\Axiom\co\AxiomTy \in \GEnv}\\
        {\AxiomTy = \many{\Forall{\many\alpha~\many\chi}{\FamCtrs(\many\tau) \teq \sigma}}}}}
    {\substack {\many{\ValidType{\GEnv;\VEnv}{\tau_i}} \\
        \forall j < i.~ \nc {\AxiomTy} {i} {\many\tau} {j}}}
    {\substack {\ValidCtx {\GEnv;\VEnv}\\
        \ResTyping {\GEnv;\VEnv} {\many{q}} {\many\chi[\alpha_i/\tau_i]} }};
    {\CoTyping {\GEnv;\VEnv} {\qbranch i {\many\tau} {\many q}} {\FamCtrs (\many\sigma\many{[\alpha_i/\tau_i]}) \teq \sigma_0\many{[\alpha_i/\tau_i]}}}}
}

\newcommand\QCoQual{
  \ib{\irule[\trule{co-qual}]
    {\many{\Typing \TEnv {\Co_i} {\tau_i\teq\sigma_i}}^{i<3}};
    {\CoTyping \TEnv {\Co_1\teq\Co_2 \then\Co_3} {(\tau_1\teq\tau_2\then\tau_2)\teq(\sigma_1\teq\sigma_2\then\sigma_3)}}}}

\newcommand\QCoVar{
  \ib{\irule[\trule{co-var}]
    {c\co\Preds \in \VEnv};
    {\Typing {\GEnv;\VEnv} {c} \Preds}}
}

% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}[ht]{c c}
%       \QCoVar & \QCoAxiom\\
%       \QCoAbs & \QCoQual \\
%     \end{array}
%   \]
%   \[
%     \begin{array}{c c c}
%       \QCoApp & \QAssume
%     \end{array}
%   \]
%   \caption[Selected Typing Judgments for \QLTF]{Selected Typing Judgments \QLTF{}}
%   \label{fig:tf-constrained-typing}
% \end{figure}

% The typing judgments new to this system are shown in \pref{fig:tf-constrained-typing}.
% The rule \trule{t-coabs} abstracts over coercion variable while \trule{t-coapp} applies a coercion
% argument to a term. We have a new version of axiom application rule \trule{co-qaxiom}.
% It is very similar to \trule{co-axiom}, except that we need
% to provide extra validity resolutions $\many q$ that instantiate the validity assumptions $\many\chi$.
% The validity resolutions are of the form $(\tau|\Co)$ where the type $\alpha$
% in validity assumptions $(\alpha|c\co\FamCtrs(\many\tau)\teq\sigma)$ is instantiated to $\tau$ and
% $\Co$ proves the equality and instantiates $c$. This is exactly what the rule \trule{v-resc} does.
% % We write $[\chi/q]$ for a substitution where the assumption $\chi$ is substituted by $q$.
% Finally, The rule \trule{t-assum} is the special rule that says we are allowed to assume arbitrary applications
% of a type family would give us a type free type. We can indeed do this by the definition of total type family.

\newcommand\QTyRed{
  \ib{\irule[\trule{qty-red}]
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1} };
    {\tystepsto \GEnv {\TEvalCtxt{\FamCtrs(\many\tau)}} {\TEvalCtxt{\tau_1}}} }
}
\newcommand{\QTyTopRed}{
  \ib{\irule[\trule{qty-red-top}]
    {\substack{ {\Axiom\co\AxiomTy\in\GEnv}\\
        {\AxiomTy_i = \Forall{\many\alpha_i~\many\chi_i}\FamCtrs(\many{\sigma_i}) \teq \sigma_0}\\
        {\forall j < i. ~\nc \AxiomTy i {\many\tau} j}
      }}
    {\substack {{\many\chi_i = \many{(\alpha'|c\co\MoreFamCtrs(\many\tau')\teq\alpha')}}\\
        {\tystepsto \GEnv {\many{\MoreFamCtrs(\Subst_1\many\tau')}} \many{\tau_0}}}}
    {\substack {{\Subst_1 = \mgu{\many\sigma_i}{\many\tau}}\\
        {\Subst_2 = [\many{\chi_i}\mapsto\many{\MoreFamCtrs(\Subst_1\many\tau')\teq\tau_0}]}\\
        {\tau_1 = \Subst_1\Subst_2\sigma_0}\\
      }};
    {\tystepsto \GEnv {\FamCtrs(\many\tau)} {\tau_1}} }
}  

\begin{figure}[ht]
    \small
  \[
  \begin{array}[ht]{c c}
    \QTyRed & \QTyTopRed
  \end{array}
  \]
  \caption{Type reduction}
  \label{fig:tc-constrained-tyred}
\end{figure}

The type reduction relation is given using two rules \trule{qty-red-top} and \trule{qty-red}.
The rule \trule{qty-red-top} does the heavy lifting of producing the correct substitutions
for types ($\Subst_1$) as well as evaluation resolutions ($\Subst_2$). The correct
equation selection is done by $\noconflict$ criterion which is slightly different than before,
as we have a weaker apartness check.
The specialty of this relation is that we ensure applying type arguments to type families only when
they satisfy proper constraints with the use of evaluation resolutions,
thus guaranteeing every type reduction to eventually obtain a type family free type.
Type family free types, or value types, do not reduce; none of the equations in the
ground context have left hand sides as a value type.
We can thus prove termination for the type reduction relation.
\begin{lemma}[\QLTF Type Reduction Terminates] For all types $\tau$, $\manytystepsto\GEnv\tau\GTy$\end{lemma}
The definition of goodness can now be relaxed from the restriction that type families
cannot appear in the left hand side of the type family equations,
as during their compilation into axioms
the type family occurancees will be abstracted out into evaluation assumptions $\chi$.
\begin{property}[$\Good~\GEnv$ relaxed]
  A ground context ($\GEnv$) is good, written $\Good\GEnv$, when
  the following conditions are met for all $\Axiom\co\AxiomTy\in\GEnv$ and
  $\AxiomTy$ is of the form $\many{\Forall{\many\alpha~\many\chi}\FamCtrs_i(\FamPattern_i)\teq\sigma}$:
  \begin{enumerate}
  \item There exists an $\FamCtrs$ such that  $\forall i.~\FamCtrs_i = \FamCtrs$.
  \item The binding variables $\many\alpha$ occur at least once in the type arguments $\many\tau$,
    on the left hand side of the equation.
  \end{enumerate}
\end{property}
With the new reduction relation defined above, and knowing that it is always terminates,
we can use Newman's lemma\cite{newman_theories_1942} to prove that type reduction is confluent using
local confluence just as we did in \CLTF. However, we get a stronger consistency and hence type soundness lemma as follows:
\begin{lemma}[$\GEnv$ Consistency] If $\Good\GEnv$, then $\GEnv$ is consistent \end{lemma}
\begin{lemma}[\QLTF Type Soundness] If $\GEnv$ consistent, then \QLTF is type sound. \end{lemma}
% \subsection{Type safety of \QLTF}\label{subsec:tf-constrained-safety} 
% \newcommand\TQPush{
%   \ib{\irule[\trule{t-qpush}]
%     {\substack {{v = \Lam c \Preds \Tm}\\
%         {\MoreCo_0 = \nth 0 \MoreCo}}}
%     {\substack {{\MoreCo_1 = \sym{\nth 1 \MoreCo}}\\
%         {\MoreCo_2 = \nth 2 \MoreCo}}};
%     {\stepsto {(\cast v \MoreCo)\App \Co} {\cast {v\App(\comp{\comp{\MoreCo_0}{\Co}}{\MoreCo_1})} \MoreCo_2}}
%   }
%   }

% \newcommand\TQResolve{
%   \ib{\irule[\trule{t-qres}]
%     {\chi = (\alpha|c\co\FamCtrs(\many\tau)\teq\alpha)}
%     {\FamCtrs(\many\tau) \Downarrow q};
%     {\stepsto {\tassume\chi\Tm} {e[\chi/q]}}}
% }

% \newcommand\TQBeta{
%   \ib{\irule[\trule{t-c$\beta$}];
%     {\stepsto {(\Lam c \Preds \Tm)\App\Co } {\Tm[c/\Co]}}}
% }
% Selected rules for term evaluation are shown in \pref{fig:tf-constrained-opsem}.
% The rule \trule{t-qres} evaluates a constraint function application similar to function application
% while the rule \trule{t-qpush} splits the inner coercion $\MoreCo$ so that it can be commuted with
% the coercion application $\Co$. The rule \trule{t-qres} is the rule that illuminates the evaluation
% for total type family constructors. The clause $\FamCtrs(\many\tau) \Downarrow q$ says that we
% find a witness for $\FamCtrs(\tau)$ reduction to a ground type to build an appropriate evaluation resolution
% and apply it to the enclosing term.
% \begin{figure}[ht]
%     \footnotesize
%   \[
%     \begin{array}{c c c}
%       \TQResolve & \TQBeta & \TQPush
%     \end{array}
%   \]
%   \caption{Small Step Operational Semantics \QLTF}
%   \label{fig:tf-constrained-opsem}
% \end{figure}
% We can thus state the preservation and progress for this system as follows:
% \begin{lemma}[Preservation \QLTF]
%   If $\Typing \empt \Tm \tau$ and $\stepsto \Tm {\Tm'}$ then $\Typing \empt {\Tm'} \tau$
% \end{lemma}
% \begin{lemma}[Progress \QLTF]
%   If $\Typing {\Sigma;\empt} \Tm \tau$
%   then either $\Tm$ is a value, or $\Tm$ is a coerced value of the form $\cast {\Tm'} \Co$ where $\Tm'\in\Val$
%   or there exists a $\Tm_1$ such that $\stepsto \Tm {\Tm_1}$.
% \end{lemma}


% \section{Related Work}\label{sec:related-work}
% Functional dependencies have also been formalized using constraint handling rules (CHR),
% a technique from logic programming\cite{sulzmann_understanding_2007}. There is no known
% implementation of functional dependencies using CHR.

% There are several variations of type families that have been explored and implemented in GHC.
% Open type families\cite{schrijvers_type_2008}, which predates closed type families,
% are extendable in a sense that the programmer can add more equations.
% To maintain both, extensibility and compatibility, open type families disallow overlapping equations.
% A system with both closed type families and open type families can co-exist without hiccups. This is
% indeed the current implimentaion of GHC. The semantics of the instance equations is similar to
% that of unordered collection of type equations, unlike
% closed type families, where the equations are considered in a top to bottom fashion.
% Associated types\cite{chakravarty_associated_2005} are a syntactic variation of open type families.
% Each typeclass has an associated type parameterized over typeclass parameters. Each instance of such typeclass
% specifies what the associated type's interpretation in the context. Injective type families\cite{stolarek_injective_2015}
% uses the idea from functional dependencies to specify additional injective constraints that the type family instance
% should satisfy to aid type inference.

\section{Conclusion and Future Work}\label{sec:conclusion}
% All three systems described in the paper have a common property that they are based on
% the principle of type erasure. The type analysis is performed at compile time and
% the types are erased from the programs at runtime.
% This ensures that there is no runtime overheads because of types.
% Due to type safety properties of each of these systems, we are guaranteed
% that if a program passes the type check then it does not crash at runtime.
% A feature that we have not included in each of the systems is the system of kinds, or type of types.
% They provide a way to have partially applied data constructors. The reason to not include them is that
% they are orthogonal to our discussion. Adding them to the system will not change type safety of the language.

% With squinting eyes, typeclasses with functional dependencies and type families are trying to achieving the
% same goal---computation on types. While functional dependencies have a flavor of relations,
% type families have a flavor of equations. Haskell programmers using GHC,
% prefer functional programming over logic programming making type families their preferred choice.
% Further, a buggy implementation of functional dependencies in GHC, does not help its case either.
% A formal proof about the equality of the expressive power of functional dependencies and
% type families is an open problem\cite{TODO}. 

Type computation, either using functional dependencies or type families
is an attractive feature for programmers as it considerably improves language expressivity.
If functional dependencies are morally equivalent to type families
one would expect to have either of the two cases to be true
1) translation mechanism that can go from one style to another or 2)
translation of both the language features into a common intermediate language.
As of now both of these remain an active area or research\cite{karachalias_elaboration_2017,sulzmann_understanding_2007}.

The type safety formalization of closed type families hinges on the assumption that
type family reduction are terminating. This problem is effectively solved by using constrained type families.
In conclusion, the motivation of constraint type families is to reunite
the idea of functional dependencies and type families that had previously diverged.
The use of equality constraints to ensure that type family applications are well defined
is reminiscent of the use of functional dependencies to ensure typeclass instances are well defined.
\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{typeclasses}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
